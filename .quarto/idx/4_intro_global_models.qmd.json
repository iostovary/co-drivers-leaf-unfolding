{"title":"Models","markdown":{"yaml":{"output":"html_document","editor_options":{"chunk_output_type":"inline"},"execute":{"freeze":false}},"headingText":"Models","containsRefs":false,"markdown":"\n\n\nThis section describes the modelling process and the model groups reference, global and final models.\n\n```{r source, include=FALSE}\nlocation <- paste0(getwd())\nsource(paste0(\"../00_helpers/setup.R\")) #common libraries and custom functions\nsource(paste0(\"../00_helpers/species_and_phases.R\"))\n\nlib_modelling <- c(\n  \"nlme\",\n  \"MuMIn\",\n  \"cAIC4\"\n  )\npackage_fun(lib_modelling, \"modelling\")\n```\n\n## Technical implementation\n\nRandom effects as well as autoregressive parameters for all models and complex fixed effects for the global models were stored in objects and supplied to the different models.\n\n### Universal random effects\n\nIn all models the grouping variable METEO_ID was used. Nested groupings to account for different observers were not possible due to insufficient observer levels within the same time series.\n\n```{r random-simple, echo=TRUE, filename=\"Random effect.\"}\nrandom_simple <- as.formula(~ 1 | METEO_ID)\nsaveRDS(random_simple, paste0(path_output_data, \"/random_simple.rds\"))\n```\n\n### Universal autoregressive parameter\n\nAn autoregressive parameter was used to account for the temporal autocorrelation in the residuals. The parameter was estimated for each METEO_ID.\n\n```{r autoregressive-parameter, echo=TRUE, filename=\"Autoregressive parameter.\"}\nautoregression_simple <- corAR1(form = ~ year | METEO_ID)\nsaveRDS(autoregression_simple, paste0(path_output_data, \"/autoregression_simple.rds\"))\n```\n\n## Reference models\n\nThe **traditional reference** models contain only a linear warming term. They represent the typical approach to analyse phenological data. I then tested whether the temperature terms are in fact linear, polynomial or whether both terms are required. Consequently the **refined reference** models contain a linear and a quadratic warming term with or without a cooling term. They serve as a contrast for additional parameters such as tree height or stand height.\n\n```{r generate-traditional-reference-models, echo=TRUE}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n    \n    models <- list(\n      ref_true_mai_int = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_true_con_int = tryCatch(\n        lme(fixed = doy ~ GDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_true_mai_slo = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream,\n            random = ~ 1 + GDD_mainstream | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n\n      ref_true_con_slo = tryCatch(\n        lme(fixed = doy ~ GDD_conservative,\n            random = ~ 1 + GDD_conservative | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n      )\n   \n      if (!is.null(models)) {\n        saveRDS(models, paste0(path_output_data, \"/ref_true\", \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      } else {\n        message(\"Something for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n```\n\n```{r generate-temp-test-models, echo=TRUE}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    models <- list(\n      temp_test_mai_int = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree = 2), \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_mai_slo = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree = 2), \n            random = ~ 1 + GDD_mainstream | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_con_int = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_con_slo = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n            random = ~ 1 + GDD_conservative | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n      )\n   \n      if (!is.null(models)) {\n        saveRDS(models, paste0(path_output_data, \"/temp_test\", \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      } else {\n        message(\"Something for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n```\n\n```{r generate-refined-reference-models, echo=TRUE}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n    \n    # create refined reference models\n    models <- list(\n      ref_imp_mai_int_poly = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree=2) * CDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_mai_int_line = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream * CDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_con_int_poly = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree=2) * CDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_con_int_line = tryCatch(\n        lme(fixed = doy ~ GDD_conservative * CDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n    )\n   \n    for (model_name in names(models)) {\n      model <- models[[model_name]]\n      \n      if (!is.null(model)) {\n        selected_subset <- NULL\n\n        dredge_result <- dredge(model, \n                                  # extra = list(\"RMSE\" = function(x) sqrt(mean(residuals(x)^2))),\n                                  rank = list(cAIC = fun_get_caic),\n                                  fixed = c(\"poly(GDD_mainstream, degree = 2)\", \"GDD_mainstream\", \"poly(GDD_conservative, degree = 2)\", \"GDD_conservative\")\n                                  )\n          \n          ref <- get.models(dredge_result, subset = TRUE, method = \"ML\") %>% setNames(paste0(model_name, \"_\", seq_along(.)))\n\n          \n          saveRDS(ref, paste0(path_output_data, \"/\",\n                              model_name, \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n        } else {\n        message(\"Model \", model_name, \" for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n}\n```\n\n## Global models\n\nBased on the hypothesis that the adjusted effects of temperature, drought, stand structure, soil characteristics and topography influence the timing of leaf unfolding two global models (mainstream and conservative) were developed. The method for calculating the temperature sums can impact the results considerably. Consequently the global model \"**mainstream\"** uses GDD and CDD sums according to the common approach to end accumulation at the mean doy per site, whereas the global model\"**conservative\"** uses GDD and CDD sums that were ended at the earliest 5% percentile of doys per site.\n\n#### Fixed mainstream effects\n\n```{r fixed-mainstream, echo=TRUE, filename=\"Loop to generate all mainstream fixed effects for all species.\"}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    if (phase == \"leaf unfolding\") {\n      if (species == \"FS\") { # global model for evergreens\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"LD\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"PA\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"TC\"){\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n        }\n      }\n    \n    else { # global model for other phase\n      fixed_effects <- as.formula(doy ~ other)\n    }\n    \n    saveRDS(fixed_effects, paste0(path_output_data, \"/fixed_mainstream_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n  }\n}\n```\n\n#### Fixed conservative effects\n\n```{r fixed-clean, echo=TRUE, filename=\"Loop to generate all conservative fixed effects for all species.\"}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    if (phase == \"leaf unfolding\") {\n      if (species == \"FS\") { # global model for evergreens\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_conservative, degree=2) * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"LD\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_conservative, degree=2) * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"PA\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_conservative, degree=2) +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"TC\"){\n        fixed_effects <- as.formula(doy ~\n          GDD_conservative * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n        }\n      }\n    \n    else { # global model for other phase\n      fixed_effects <- as.formula(doy ~ other)\n    }\n    \n    saveRDS(fixed_effects, paste0(path_output_data, \"/fixed_conservative_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n  }\n}\n```\n\n#### Global model combinations\n\n```{r species-specific-global-models, echo=TRUE, filename=\"Loop to generate all global models for all species.\"}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    # load data\n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    # load fixed effects\n    fixed_conservative <- readRDS(paste0(path_output_data, \"/fixed_conservative_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n    fixed_mainstream <- readRDS(paste0(path_output_data, \"/fixed_mainstream_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n    \n    # load random effects  \n    random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    \n    # load autoregression parameter\n    autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n\n    # mainstream\n      # random simple\n      tryCatch({\n      global_maisim  <- eval(bquote(lme(fixed = fixed_mainstream, random = random_simple, data = data, method = \"ML\", correlation = autoregression_simple)))\n      saveRDS(global_maisim, paste0(path_output_data, \"/global_mai_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      }, error = function(e) message(\"Error in model with global_maisim for \", species, \" \", phase, \": \", e$message))\n\n    # conservative\n      # random simple\n      tryCatch({\n      global_consim <- eval(bquote(lme(fixed = fixed_conservative, random = random_simple, data = data, method = \"ML\", correlation = autoregression_simple)))\n      saveRDS(global_consim, paste0(path_output_data, \"/global_con_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      }, error = function(e) message(\"Error in model with global_consim for \", species, \" \", phase, \": \", e$message))\n  }\n}\n```\n\n```{r check-global, eval=FALSE, internal=TRUE}\ncheck_fixed_LD <- readRDS(paste0(path_output_data, \"/fixed_conservative_LD_leaf_unfolding.rds\"))\nprint(check_fixed_LD)\ncheck_data_LD <- readRDS(paste0(path_output_data, \"/data_unscaled_LD_leaf_unfolding.rds\"))\nsummary(check_data_LD)\ncheck_LD <- readRDS(paste0(path_output_data, \"/global_con_LD_leaf_unfolding.rds\"))\nsummary(check_LD)\ncheck_TC <- readRDS(paste0(path_output_data, \"/global_TC_leaf_unfolding.rds\"))\nsummary(check_TC) \n```\n\n### Generation of global model variations\n\nThe variations of all global models were created with mumln::dredge. The function was fitted with each global model and set to test all combinations that contained a growing degree day term and ≤ 10 terms in total.\n\n```{r dredge-code, echo=TRUE, filename=\"Execution of mumln:dredge via an array for all global models.\"}\n#| eval: FALSE \n#| file: 4_euler_dredge_all.R\n```\n\nParameter weights were calculated for all models with delta cAIC \\< 4 and \\< 2 [@burnham2002] for further consideration and the three models with the lowest cAIC (**best models**) and the models with the least number of parameters (**parsimonious models**) were extracted for further analysis.\n\n### Limitations\n\nWe wanted to adjust the social situation with an interaction with edge distance. However, this led to issues with the covariance matrix. Edge-distance was removed, because it has little validity as a main effect. Furthermore, it would have been useful to test the global model with a warming term in interaction with all other terms. However, this is computationally expensive. Therefore, only the most important interactions were kept.\n<!-- start:internal -->\nExploration of the global models revealed that leaf colouring lag has a high parameter weight for the 20 best connes and mainnes models of Tilia cordata, maisim models of Larix decidua and for all best models of Fagus sylvativa. Nevertheless the parameter was only significant (p \\< 0.05) in the three best models for Fagus sylvativa that had simple random effects.\n<!-- end:internal -->\nDue to a substantial amount of missing values for leaf colouring containing it was removed from the global models.\n\n## Final models\n\nThe final models were generated from the best and most parsimonious model variations of the global model. They demonstrate what the effects of important parameters could look like and how good they would be with prediction. If the quadratic term was significant, non-significant linear terms were kept. If only the linear term was significant, the quadratic term was discarded. Interactions were only kept where significant.\n\n```{r create-species-results-qmd}\nfor (species in species_list) {\n  for (phase in phase_list) {\n  # Read the template content\n  qmd_content <- readLines(paste0(location, \"/5_species_template.qmd\"))\n  \n  header <- case_when(species == \"FS\" ~ \"Fagus sylvatica\",\n                      species == \"LD\" ~ \"Larix decidua\",\n                      species == \"PA\" ~ \"Picea abies\",\n                      species == \"TC\" ~ \"Tilia cordata\")\n  \n  # paste species and phase to the template lines\n  qmd_content[10] <- paste0(\"phase <- \\\"\", phase, \"\\\"\")\n  qmd_content[11] <- paste0(\"species <- \\\"\", species, \"\\\"\")\n  qmd_content[14] <- paste0(\"# \", header)\n  \n  # Define the path for the new .qmd file\n  species_qmd_path <- file.path(location, paste0(\"/5_results_\", species, \"_\", gsub(\" \", \"_\", phase) , \".qmd\"))\n  \n  # Write the modified content to the new .qmd file\n  writeLines(qmd_content, species_qmd_path)\n  }\n}\n```\n\n## Model diagnostics\n\nCompliance with model assumptions was assessed with a residual analysis for each set of species specific models. Multicollinearity was assessed with the corvif function by @zuur2009. Cooks distance and leverage was assessed with HLMdiag::cooks.distance and HLMdiag::leverage because more common packages and functions were incompatible with nlme::lme-objects. Some models with temperature parametrized to the mean site leaf unfolding date (mainstream) had issues with residual distributions. Therefore only models with temperature parametrized to the $Q_{0.05}$ site leaf unfolding date (conservative) were considered for the model selection.\n\n```{r create-species-residuals-qmd, internal = TRUE}\nfor (species in species_list) {\n  for (phase in phase_list) {\n  # Read the template content\n  qmd_content <- readLines(paste0(location, \"/7_residual_template.qmd\"))\n  \n  header <- case_when(species == \"FS\" ~ \"Fagus sylvatica\",\n                      species == \"LD\" ~ \"Larix decidua\",\n                      species == \"PA\" ~ \"Picea abies\",\n                      species == \"TC\" ~ \"Tilia cordata\")\n  \n  # paste species and phase to the template lines\n  qmd_content[15] <- paste0(\"phase <- \\\"\", phase, \"\\\"\")\n  qmd_content[16] <- paste0(\"species <- \\\"\", species, \"\\\"\")\n  qmd_content[19] <- paste0(\"# \", header)\n  \n  # Define the path for the new .qmd file\n  species_qmd_path <- file.path(location, paste0(\"/7_residuals_\", species, \"_\", gsub(\" \", \"_\", phase) , \".qmd\"))\n  \n  # Write the modified content to the new .qmd file\n  writeLines(qmd_content, species_qmd_path)\n  }\n}\n```\n\n## Model selection\n\nModels that met all diagnostic criteria were selected and compared using the cAIC and RMSE.\n","srcMarkdownNoYaml":"\n\n# Models\n\nThis section describes the modelling process and the model groups reference, global and final models.\n\n```{r source, include=FALSE}\nlocation <- paste0(getwd())\nsource(paste0(\"../00_helpers/setup.R\")) #common libraries and custom functions\nsource(paste0(\"../00_helpers/species_and_phases.R\"))\n\nlib_modelling <- c(\n  \"nlme\",\n  \"MuMIn\",\n  \"cAIC4\"\n  )\npackage_fun(lib_modelling, \"modelling\")\n```\n\n## Technical implementation\n\nRandom effects as well as autoregressive parameters for all models and complex fixed effects for the global models were stored in objects and supplied to the different models.\n\n### Universal random effects\n\nIn all models the grouping variable METEO_ID was used. Nested groupings to account for different observers were not possible due to insufficient observer levels within the same time series.\n\n```{r random-simple, echo=TRUE, filename=\"Random effect.\"}\nrandom_simple <- as.formula(~ 1 | METEO_ID)\nsaveRDS(random_simple, paste0(path_output_data, \"/random_simple.rds\"))\n```\n\n### Universal autoregressive parameter\n\nAn autoregressive parameter was used to account for the temporal autocorrelation in the residuals. The parameter was estimated for each METEO_ID.\n\n```{r autoregressive-parameter, echo=TRUE, filename=\"Autoregressive parameter.\"}\nautoregression_simple <- corAR1(form = ~ year | METEO_ID)\nsaveRDS(autoregression_simple, paste0(path_output_data, \"/autoregression_simple.rds\"))\n```\n\n## Reference models\n\nThe **traditional reference** models contain only a linear warming term. They represent the typical approach to analyse phenological data. I then tested whether the temperature terms are in fact linear, polynomial or whether both terms are required. Consequently the **refined reference** models contain a linear and a quadratic warming term with or without a cooling term. They serve as a contrast for additional parameters such as tree height or stand height.\n\n```{r generate-traditional-reference-models, echo=TRUE}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n    \n    models <- list(\n      ref_true_mai_int = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_true_con_int = tryCatch(\n        lme(fixed = doy ~ GDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_true_mai_slo = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream,\n            random = ~ 1 + GDD_mainstream | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n\n      ref_true_con_slo = tryCatch(\n        lme(fixed = doy ~ GDD_conservative,\n            random = ~ 1 + GDD_conservative | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n      )\n   \n      if (!is.null(models)) {\n        saveRDS(models, paste0(path_output_data, \"/ref_true\", \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      } else {\n        message(\"Something for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n```\n\n```{r generate-temp-test-models, echo=TRUE}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    models <- list(\n      temp_test_mai_int = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree = 2), \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_mai_slo = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree = 2), \n            random = ~ 1 + GDD_mainstream | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_con_int = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      temp_test_con_slo = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree = 2), \n            random = ~ 1 + GDD_conservative | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n      )\n   \n      if (!is.null(models)) {\n        saveRDS(models, paste0(path_output_data, \"/temp_test\", \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      } else {\n        message(\"Something for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n```\n\n```{r generate-refined-reference-models, echo=TRUE}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n    \n    # create refined reference models\n    models <- list(\n      ref_imp_mai_int_poly = tryCatch(\n        lme(fixed = doy ~ poly(GDD_mainstream, degree=2) * CDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_mai_int_line = tryCatch(\n        lme(fixed = doy ~ GDD_mainstream * CDD_mainstream, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_con_int_poly = tryCatch(\n        lme(fixed = doy ~ poly(GDD_conservative, degree=2) * CDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL),\n      \n      ref_imp_con_int_line = tryCatch(\n        lme(fixed = doy ~ GDD_conservative * CDD_conservative, \n            random = ~ 1 | METEO_ID, data = data, method = \"ML\", correlation = autoregression_simple),\n        error = function(e) NULL)\n    )\n   \n    for (model_name in names(models)) {\n      model <- models[[model_name]]\n      \n      if (!is.null(model)) {\n        selected_subset <- NULL\n\n        dredge_result <- dredge(model, \n                                  # extra = list(\"RMSE\" = function(x) sqrt(mean(residuals(x)^2))),\n                                  rank = list(cAIC = fun_get_caic),\n                                  fixed = c(\"poly(GDD_mainstream, degree = 2)\", \"GDD_mainstream\", \"poly(GDD_conservative, degree = 2)\", \"GDD_conservative\")\n                                  )\n          \n          ref <- get.models(dredge_result, subset = TRUE, method = \"ML\") %>% setNames(paste0(model_name, \"_\", seq_along(.)))\n\n          \n          saveRDS(ref, paste0(path_output_data, \"/\",\n                              model_name, \"_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n        } else {\n        message(\"Model \", model_name, \" for \", species, \" \", phase, \" failed.\")\n      }\n    }\n  }\n}\n```\n\n## Global models\n\nBased on the hypothesis that the adjusted effects of temperature, drought, stand structure, soil characteristics and topography influence the timing of leaf unfolding two global models (mainstream and conservative) were developed. The method for calculating the temperature sums can impact the results considerably. Consequently the global model \"**mainstream\"** uses GDD and CDD sums according to the common approach to end accumulation at the mean doy per site, whereas the global model\"**conservative\"** uses GDD and CDD sums that were ended at the earliest 5% percentile of doys per site.\n\n#### Fixed mainstream effects\n\n```{r fixed-mainstream, echo=TRUE, filename=\"Loop to generate all mainstream fixed effects for all species.\"}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    if (phase == \"leaf unfolding\") {\n      if (species == \"FS\") { # global model for evergreens\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"LD\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"PA\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"TC\"){\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_mainstream, degree=2) * CDD_mainstream +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n        }\n      }\n    \n    else { # global model for other phase\n      fixed_effects <- as.formula(doy ~ other)\n    }\n    \n    saveRDS(fixed_effects, paste0(path_output_data, \"/fixed_mainstream_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n  }\n}\n```\n\n#### Fixed conservative effects\n\n```{r fixed-clean, echo=TRUE, filename=\"Loop to generate all conservative fixed effects for all species.\"}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    if (phase == \"leaf unfolding\") {\n      if (species == \"FS\") { # global model for evergreens\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_conservative, degree=2) * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"LD\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_conservative, degree=2) * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"PA\") {\n        fixed_effects <- as.formula(doy ~\n          poly(GDD_conservative, degree=2) +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n      } else if (species == \"TC\"){\n        fixed_effects <- as.formula(doy ~\n          GDD_conservative * CDD_conservative +\n          poly(DROUGHT, degree=2) * poly(AWC, degree=2) +\n          poly(SLOPE_ASPECT_HL, degree=2) * poly(SLOPE_INCLINATION_DEG, degree=2) + RELIEF + TREE_ELEVATION +\n          SOCIAL_SITUATION + poly(TREE_HEIGHT, degree=2) * poly(STAND_HEIGHT, degree=2))\n        }\n      }\n    \n    else { # global model for other phase\n      fixed_effects <- as.formula(doy ~ other)\n    }\n    \n    saveRDS(fixed_effects, paste0(path_output_data, \"/fixed_conservative_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n  }\n}\n```\n\n#### Global model combinations\n\n```{r species-specific-global-models, echo=TRUE, filename=\"Loop to generate all global models for all species.\"}\nfor (phase in phase_list) {\n  for (species in species_list) {\n    \n    # load data\n    data <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\")) %>%\n      rename_fun() %>%\n      select(-LEAF_COLOURING_LAG) %>%\n      filter(complete.cases(.)) %>%\n      mutate(RELIEF = factor(RELIEF),\n             SOCIAL_SITUATION = factor(SOCIAL_SITUATION))\n    \n    # load fixed effects\n    fixed_conservative <- readRDS(paste0(path_output_data, \"/fixed_conservative_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n    fixed_mainstream <- readRDS(paste0(path_output_data, \"/fixed_mainstream_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n    \n    # load random effects  \n    random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n    \n    # load autoregression parameter\n    autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n\n    # mainstream\n      # random simple\n      tryCatch({\n      global_maisim  <- eval(bquote(lme(fixed = fixed_mainstream, random = random_simple, data = data, method = \"ML\", correlation = autoregression_simple)))\n      saveRDS(global_maisim, paste0(path_output_data, \"/global_mai_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      }, error = function(e) message(\"Error in model with global_maisim for \", species, \" \", phase, \": \", e$message))\n\n    # conservative\n      # random simple\n      tryCatch({\n      global_consim <- eval(bquote(lme(fixed = fixed_conservative, random = random_simple, data = data, method = \"ML\", correlation = autoregression_simple)))\n      saveRDS(global_consim, paste0(path_output_data, \"/global_con_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n      }, error = function(e) message(\"Error in model with global_consim for \", species, \" \", phase, \": \", e$message))\n  }\n}\n```\n\n```{r check-global, eval=FALSE, internal=TRUE}\ncheck_fixed_LD <- readRDS(paste0(path_output_data, \"/fixed_conservative_LD_leaf_unfolding.rds\"))\nprint(check_fixed_LD)\ncheck_data_LD <- readRDS(paste0(path_output_data, \"/data_unscaled_LD_leaf_unfolding.rds\"))\nsummary(check_data_LD)\ncheck_LD <- readRDS(paste0(path_output_data, \"/global_con_LD_leaf_unfolding.rds\"))\nsummary(check_LD)\ncheck_TC <- readRDS(paste0(path_output_data, \"/global_TC_leaf_unfolding.rds\"))\nsummary(check_TC) \n```\n\n### Generation of global model variations\n\nThe variations of all global models were created with mumln::dredge. The function was fitted with each global model and set to test all combinations that contained a growing degree day term and ≤ 10 terms in total.\n\n```{r dredge-code, echo=TRUE, filename=\"Execution of mumln:dredge via an array for all global models.\"}\n#| eval: FALSE \n#| file: 4_euler_dredge_all.R\n```\n\nParameter weights were calculated for all models with delta cAIC \\< 4 and \\< 2 [@burnham2002] for further consideration and the three models with the lowest cAIC (**best models**) and the models with the least number of parameters (**parsimonious models**) were extracted for further analysis.\n\n### Limitations\n\nWe wanted to adjust the social situation with an interaction with edge distance. However, this led to issues with the covariance matrix. Edge-distance was removed, because it has little validity as a main effect. Furthermore, it would have been useful to test the global model with a warming term in interaction with all other terms. However, this is computationally expensive. Therefore, only the most important interactions were kept.\n<!-- start:internal -->\nExploration of the global models revealed that leaf colouring lag has a high parameter weight for the 20 best connes and mainnes models of Tilia cordata, maisim models of Larix decidua and for all best models of Fagus sylvativa. Nevertheless the parameter was only significant (p \\< 0.05) in the three best models for Fagus sylvativa that had simple random effects.\n<!-- end:internal -->\nDue to a substantial amount of missing values for leaf colouring containing it was removed from the global models.\n\n## Final models\n\nThe final models were generated from the best and most parsimonious model variations of the global model. They demonstrate what the effects of important parameters could look like and how good they would be with prediction. If the quadratic term was significant, non-significant linear terms were kept. If only the linear term was significant, the quadratic term was discarded. Interactions were only kept where significant.\n\n```{r create-species-results-qmd}\nfor (species in species_list) {\n  for (phase in phase_list) {\n  # Read the template content\n  qmd_content <- readLines(paste0(location, \"/5_species_template.qmd\"))\n  \n  header <- case_when(species == \"FS\" ~ \"Fagus sylvatica\",\n                      species == \"LD\" ~ \"Larix decidua\",\n                      species == \"PA\" ~ \"Picea abies\",\n                      species == \"TC\" ~ \"Tilia cordata\")\n  \n  # paste species and phase to the template lines\n  qmd_content[10] <- paste0(\"phase <- \\\"\", phase, \"\\\"\")\n  qmd_content[11] <- paste0(\"species <- \\\"\", species, \"\\\"\")\n  qmd_content[14] <- paste0(\"# \", header)\n  \n  # Define the path for the new .qmd file\n  species_qmd_path <- file.path(location, paste0(\"/5_results_\", species, \"_\", gsub(\" \", \"_\", phase) , \".qmd\"))\n  \n  # Write the modified content to the new .qmd file\n  writeLines(qmd_content, species_qmd_path)\n  }\n}\n```\n\n## Model diagnostics\n\nCompliance with model assumptions was assessed with a residual analysis for each set of species specific models. Multicollinearity was assessed with the corvif function by @zuur2009. Cooks distance and leverage was assessed with HLMdiag::cooks.distance and HLMdiag::leverage because more common packages and functions were incompatible with nlme::lme-objects. Some models with temperature parametrized to the mean site leaf unfolding date (mainstream) had issues with residual distributions. Therefore only models with temperature parametrized to the $Q_{0.05}$ site leaf unfolding date (conservative) were considered for the model selection.\n\n```{r create-species-residuals-qmd, internal = TRUE}\nfor (species in species_list) {\n  for (phase in phase_list) {\n  # Read the template content\n  qmd_content <- readLines(paste0(location, \"/7_residual_template.qmd\"))\n  \n  header <- case_when(species == \"FS\" ~ \"Fagus sylvatica\",\n                      species == \"LD\" ~ \"Larix decidua\",\n                      species == \"PA\" ~ \"Picea abies\",\n                      species == \"TC\" ~ \"Tilia cordata\")\n  \n  # paste species and phase to the template lines\n  qmd_content[15] <- paste0(\"phase <- \\\"\", phase, \"\\\"\")\n  qmd_content[16] <- paste0(\"species <- \\\"\", species, \"\\\"\")\n  qmd_content[19] <- paste0(\"# \", header)\n  \n  # Define the path for the new .qmd file\n  species_qmd_path <- file.path(location, paste0(\"/7_residuals_\", species, \"_\", gsub(\" \", \"_\", phase) , \".qmd\"))\n  \n  # Write the modified content to the new .qmd file\n  writeLines(qmd_content, species_qmd_path)\n  }\n}\n```\n\n## Model selection\n\nModels that met all diagnostic criteria were selected and compared using the cAIC and RMSE.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":4,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":"html_document","warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"espresso","toc":true,"toc-depth":3,"include-in-header":{"text":"<script type=\"text/javascript\" src=\"C:/Users/iostovary/Documents/Data/00_helpers/zoom.js\"></script>"},"output-file":"4_intro_global_models.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","bibliography":["C:/Users/iostovary/Documents/Data/references.bib"],"csl":"C:/Users/iostovary/Documents/Data/citation_style_global-ecology-and-biogeography_mod_ostovary.csl","editor":"visual","page-layout":"full","code-summary":"Show the code","theme":"minty","code-folding":"hide","grid":{"body-width":"1100px"},"toc-location":"right","toc-float":{"collapsed":false,"number-sections":true},"editor_options":{"chunk_output_type":"inline"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}