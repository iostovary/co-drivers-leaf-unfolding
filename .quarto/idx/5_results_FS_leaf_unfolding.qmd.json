{"title":"Fagus sylvatica","markdown":{"yaml":{"output":"html_document","editor_options":{"chunk_output_type":"inline"},"execute":{"freeze":false}},"headingText":"Fagus sylvatica","containsRefs":false,"markdown":"\n\n```{r parameters, include=FALSE, eval=TRUE}\nphase <- \"leaf unfolding\"\nspecies <- \"FS\"\n```\n\n\n```{r source-global, include=FALSE}\nlocation <- paste0(getwd())\nsource(paste0(\"../00_helpers/setup.R\")) #common libraries and custom functions\nsource(paste0(\"../00_helpers/species_and_phases.R\"))\n\nlib_results <- c(\n  \"nlme\",\n  \"MuMIn\",\n  \"cAIC4\",\n  \"lattice\",\n  \"broom.mixed\"\n  )\npackage_fun(lib_results, \"results1\")\n\n# type of temperature parametrization\nexclude_type <- \"mai\"\n\n# function to extract conditional LogLikelihood and return NA if failed\nfun_get_log <- function(x) {\n  tryCatch({\n    cAIC(x)$loglikelihood\n  }, error = function(e) {\n    NA # Return NA or some indication of failure for models that cause an error\n  })\n}\n```\n\n## Effect shape of temperature\n\n```{r load-temp-test}\ntemp_test <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^temp_test.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\ntemp_test_models <- temp_test %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r load-ref-true}\nref_true <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^ref_true.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\nref_true_models <- ref_true %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r load-ref-imp}\nref_imp <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^ref_imp.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\nref_imp_models <- ref_imp %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r bind-ref}\nall_ref <- bind_rows(temp_test_models, ref_true_models, ref_imp_models) %>%\n  filter(!str_detect(model_name, exclude_type),\n         !str_detect(model_name, \"slo\"))\n```\n\n```{r extract-temp-test}\nresults_temp_test <- all_ref %>%\n  mutate(tidy = map2(model, model_name, ~broom.mixed::tidy(.x) %>% mutate(model_name = .y)), # extract coefficients and p-values\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\"),\n         calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) # extract random effects\n```\n\n```{r format-selection}\nselection_param <- results_temp_test %>%\n  select(model_name, family, cAIC, RMSE, fixed_effects) %>%\n  unnest(RMSE, cAIC) %>%\n  group_by(family) %>%\n  mutate(d.cAIC = cAIC - min(cAIC),\n         d.RMSE = RMSE - min(RMSE))\n\ntidy <- results_temp_test %>%\n  select(tidy, family) %>%\n  unnest(tidy) %>%\n  mutate(label = label_fun(term)) %>%\n  select(model_name, label, family, p.value, estimate, std.error, term)\n```\n\n```{r tbl-temp-test-selection}\n#| tbl-cap: Comparison of model performance of linear and polynomial temperature parameters with cAIC and RMSE.\n\ntable <- selection_param %>%\n  filter(!model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 3) %>%\n  arrange(family, d.cAIC) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip', buttons = \"print\"), rownames=FALSE)\ntable\n```\n\n```{r tbl-temp-test-coefficients}\n#| tbl-cap: Comparison of parameters across models with estimate, standard error, t-value and p-value\n  \ntable <- tidy %>%\n  filter(!model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 4) %>%\n  filter(!str_detect(term, \"Intercept|Observation|sd\"),\n         str_detect(model_name, \"temp_test\")) %>%\n  arrange(family) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n## Effect shape of temperature with chilling\n\n```{r tbl-shape-performance}\n#| tbl-cap: Comparison of model performance of linear and non-linear growing degree days in combination with chilling degree days. \n\ntable <- selection_param %>%\n  filter(model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 3) %>%\n  arrange(family, d.cAIC) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip', buttons = \"print\"), rownames=FALSE)\ntable\n```\n\n```{r tbl-shape-coefficients}\n#| tbl-cap: Comparison of siginificance of various growing and chilling degree day combinations.\n\ntable <- tidy %>%\n  filter(model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 4) %>%\n  filter(!str_detect(term, \"Intercept|Observation|sd\")) %>%\n  arrange(family) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n## Global model variations\n\n```{r load-objects}\nall_models <- list.files(path = paste0(path_output_data),\n                    pattern = sprintf(\"^dredge_(.*?)_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                    full.names = TRUE) %>%\n  setNames(gsub(\"^dredge_(.*?)\\\\.rds\", \"\\\\1\", basename(.))) %>%\n  lapply(readRDS)\n```\n\n<!-- start:internal -->\n\n### Model variations\n<!-- end:internal -->\n\n```{r extract-model-variations}\nvariations_d4 <- map_df(all_models, ~ .x[[\"dredge_result_d4\"]] %>%\n                          as.data.frame() %>%\n                          mutate(model_name=.x[[\"model_name\"]]) %>%\n                          mutate_if(is.numeric, signif, 3) %>%\n                          select(model_name, cAIC, delta, weight, RMSE, logLik, `(Intercept)`, contains(\"GDD\"), everything()) %>%\n                          filter(!str_detect(model_name, exclude_type)))\n\nvariations_d2 <- map_df(all_models, ~ .x[[\"dredge_result_d2\"]] %>%\n                          as.data.frame() %>%\n                          mutate(model_name=.x[[\"model_name\"]]) %>%\n                          mutate_if(is.numeric, signif, 3) %>%\n                          select(model_name, cAIC, delta, weight, RMSE, logLik, `(Intercept)`, contains(\"GDD\"), everything()) %>%\n                          filter(!str_detect(model_name, exclude_type)))\n```\n\n```{r tbl-d4-models, internal=TRUE}\n#| tbl-cap: Model variations of the global model with delta cAIC < 4. A \"+\" means the term is included but the estimate is not shown.\n\ntable <- variations_d4 %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 5), rownames=FALSE)\ntable\n```\n\n```{r tbl-d2-models, internal=TRUE}\n#| tbl-cap: Model variations of the global model with the delta cAIC < 2. A \"+\" means the term is included but the estimate is not shown.\n\ntable <- variations_d2 %>%\n  datatable(filter = 'top', rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5))\ntable\n```\n\n```{r failed-variations1, include=FALSE, internal = TRUE}\nmod <- all_models[[1]][[\"dredge_result\"]]\n\ncoef_tables <- attr(mod, \"coefTables\")\ncoef_lengths <- lapply(coef_tables, function(table) nrow(table) - 1) # +1 for the grouping variable\ncoef_lengths <- unlist(coef_lengths)\nmod$coef_lengths <- coef_lengths\n\nggplot() +\n  geom_boxplot(data=mod %>% filter(!is.na(cAIC)), aes(x = \"completed\", y = coef_lengths)) +\n  geom_boxplot(data=mod %>% filter(is.na(cAIC)), aes(x = \"failed\", y = coef_lengths), color=\"red\")+\n  xlab(\"\")+\n  ylab(\"Number of coefficients\")+\n  theme_report(hjust=0.5)\n\nmin_expected <- 2^11 \nmin_expected\n```\n\n```{r failed-variations2, fig.height=8, fig.width=8, fig.cap=\"Failed conservative models due to 'Fehler bei der Auswertung des Argumentes 'x' bei der Methodenauswahl für Funktion 'chol': System ist für den Rechner singulär: reziproke Konditionszahl' while calculating the cAIC.\", internal = TRUE}\n\ncompleted <- mod %>%\n  as.data.frame() %>%\n  mutate(status = case_when(!is.na(cAIC) ~ \"completed\",\n                            TRUE ~ \"failed\")) %>%\n  group_by(status) %>%\n  summarize(across(-coef_lengths, ~ sum(!is.na(.))),\n            total=n(),\n            mean_coeff = mean(coef_lengths, na.rm = TRUE),\n            max_coeff = max(coef_lengths, na.rm = TRUE)) %>%\n  ungroup() %>%\n  mutate(total_all = sum(total),\n         rate = total / total_all * 100)\n\nsaveRDS(completed %>% ungroup(), paste0(path_own_data, \"/output_data/failed_\", species, \"_\", phase, \".rds\"))\n\n# Convert to long format for ggplot\ncomparison_long <- completed %>%\n  select(-matches(\"(Inter|cAIC|df|delta|weight|log|name|RMSE|rate|total|coeff)\")) %>%\n  pivot_longer(cols = -status, names_to = \"parameter\", values_to = \"count\") %>%\n  mutate(parameter=label_fun(parameter))\n\n# Plot\nggplot(comparison_long, aes(x = parameter, y = count, fill = status)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  geom_text(aes(label = count), position = position_stack(vjust = 0.5), size = 3) +\n  #annotate(\"text\", x = 6, y = 2000, label = paste0(\"Failure rate \", round(ratio, 0), \"%\"), vjust = -1, hjust = 0) +\n  ylab(\"Number of models with parameter\") +\n  xlab(\"\")+\n  theme_report(angle = -90)\n```\n\n```{r tbl-variations}\n#| tbl-cap: Number of equally or almost equally informative conservative model variations and maximum model weights (Δ cAIC < 4 and < 2).\n\n# weight_checkd4 <- variations_d4 %>% group_by(model_name) %>% summarize(weight_sum = sum(weight))\n# weight_checkd2 <- variations_d2 %>% group_by(model_name) %>% summarize(weight_sum = sum(weight))\n\nweightd2 <- variations_d2 %>%\n  filter(!str_detect(model_name, exclude_type)) %>%\n  summarize(max_weight2 = max(weight))\n\nweightd4 <- variations_d4 %>%\n  filter(!str_detect(model_name, exclude_type)) %>%\n  summarize(max_weight4 = max(weight))\n\n# summarize conservative model variations\ncon_var <- variations_d4 %>%\n  filter(!str_detect(model_name, exclude_type)) %>%\n  summarize(SPECIES_SHORT = species,\n            d4 = sum(delta <4),\n            d2 = sum(delta <2)) %>%\n  bind_cols(weightd4, weightd2)\n\ntable <- con_var %>%\n  select(-SPECIES_SHORT) %>%\n  datatable(rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5),\n            colnames = c('number of models (Δ < 4)' = \"d4\",\n                         'number of models (Δ < 2)' = \"d2\",\n                         'maximum weight (Δ < 4)' = \"max_weight4\",\n                         'maximum weight (Δ < 2)' = \"max_weight2\"))\ntable\n```\n\n```{r tbl-best-models}\n#| tbl-cap: The three best model variations derived from the global model.\nbest <- list.files(path = paste0(path_output_data),\n                   pattern = sprintf(\"^best_(.*?)_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n    setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS)\n\nbest_models <- best %>%\n  flatten() %>%\n  rbind() %>%\n  as.data.frame() %>% \n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n\nbest_calls <- best_models %>% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) %>% # extract random effects\n  select(model_name, fixed_effects, random_effects)\n\nbest_calls %>%\n  select(-random_effects) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 5, dom = 'Bfrtip'), rownames=FALSE)\n```\n\n```{r tbl-parsimonious-con}\n#| tbl-cap: The three most parsimonious models derived from the global model.\nparsimonious_models <- map(all_models, ~ keep(.x, .p = str_detect(names(.x), \"parsimonious\"))) %>%\n  list_flatten() %>% # flatten list two times\n  list_flatten() %>%\n  enframe() %>%\n  rename(model = value, model_name = name) %>%\n  mutate(model_name = case_when(model_name %like% \"con\" & model_name %like% \"d4\" ~ \"parsimonious_con_d4\",\n                                model_name %like% \"con\" & model_name %like% \"d2\" ~ \"parsimonious_con_d2\",\n                                model_name %like% \"mai\" & model_name %like% \"d4\" ~ \"parsimonious_mai_d4\",\n                                model_name %like% \"mai\" & model_name %like% \"d2\" ~ \"parsimonious_mai_d2\",\n                                TRUE ~ model_name)) %>%\n  group_by(model_name) %>%\n  mutate(suffix = letters[row_number()]) %>%\n  ungroup() %>% \n  mutate(model_name = paste0(model_name, suffix)) %>%\n  filter(!str_detect(model_name, exclude_type))\n  \nparsimonious_calls <- parsimonious_models %>% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) %>% # extract random effects\n  select(model_name, fixed_effects, random_effects)\n\nparsimonious_calls %>%\n  select(-random_effects) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 5, dom = 'Bfrtip'), rownames=FALSE)\n```\n\n<!-- start:internal -->\n\n### Parameter weights\n<!-- end:internal -->\n\n```{r format-weights, echo=FALSE}\nplot_weightd4 <- map_df(all_models, ~ as.data.frame(as.matrix(.x$summary_weight_d4)), .id = \"model_id\") %>%\n  mutate(WEIGHT=as.numeric(WEIGHT),\n         category = category_fun(PARAMETER),\n         PARAMETER_ABBR = label_fun_sim(PARAMETER, \"short\"),\n         PARAMETER = label_fun_sim(PARAMETER, \"full\"),\n         DELTA = \"D4\") %>%\n  filter(!str_detect(model_id, exclude_type))\n\nplot_weightd2 <- map_df(all_models, ~ as.data.frame(as.matrix(.x$summary_weight_d2)), .id = \"model_id\") %>%\n  mutate(WEIGHT=as.numeric(WEIGHT),\n         category = category_fun(PARAMETER),\n         PARAMETER_ABBR = label_fun_sim(PARAMETER, \"short\"),\n         PARAMETER = label_fun_sim(PARAMETER, \"full\"),\n         DELTA = \"D2\") %>%\n  filter(!str_detect(model_id, exclude_type))\n```\n\n```{r fig-mumln-weights-d4, fig.width=15, fig.height=8, fig.cap=\"Sum of model weights (relative importance value) over models with delta cAIC < 4.\", internal = TRUE}\nggplot(plot_weightd4, aes(x = model_id, y = PARAMETER_ABBR, fill=WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.8, limit = c(0, 1), na.value = NA) +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"Model\") +\n  ylab(\"Parameter\") +\n  theme_report()+\n  theme(axis.text.x = element_text(hjust = 0.5))\n```\n\n```{r fig-mumln-weight-d2, fig.width= 15, fig.height=8, fig.cap=\"Sum of model weights (relative importance value) over models with delta cAIC < 2.\", internal = TRUE}\nggplot(plot_weightd2, aes(x = model_id, y = PARAMETER_ABBR, fill=WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.8, limit = c(0, 1), na.value = NA) +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"Model\") +\n  ylab(\"Parameter\") +\n  theme_report()+\n  theme(axis.text.x = element_text(hjust = 0.5))\n```\n\n```{r rm-large-objects}\nrm(all_models)\ninvisible(gc(verbose = FALSE))\n```\n\n## Model processing\n\n```{r load-data}\ndata <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\")) %>%\n  rename_fun() %>%\n  select(-LEAF_COLOURING_LAG) %>%\n  mutate(METEO_ID = factor(METEO_ID),\n         RELIEF = factor(RELIEF),\n         SOCIAL_SITUATION = factor(SOCIAL_SITUATION),\n         EDGE_DIST_IMPUTED = factor(EDGE_DIST_IMPUTED))\n```\n\n```{r load-temporal-correlation}\nautoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\nrandom_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n```\n\n```{r load-reference-refined}\nref_imp <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^ref_imp.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\nref_imp_models <- ref_imp %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r load-global-models, include=FALSE}\nglobal <- list.files(path = paste0(path_output_data),\n                     pattern = paste0(\"global.*_\", species, \"_\", gsub(\" \", \"_\", phase), \"\\\\.rds$\"),\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS)\n\nglobal_models <- global %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r species-specific-manual-models, echo=TRUE}\n# nest data set\nmanual_models_input <- data %>%\n  nest()\n\n# save to file for evaluation of manual models in the template\nsaveRDS(manual_models_input, paste0(path_output_data, \"/manual_models_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\"))\n\n# source manual models to be evaluated within template\nsource(paste0(location, \"/5_manual_\", species, \"_\", gsub (\" \", \"_\", phase), \".R\"), echo=TRUE, max.deparse.length = 5000)\n\n# format manual models to fit the data frame structure\nmanual_models <- manual_models %>%\n  pivot_longer(cols = 2:ncol(.), names_to = \"model_name\", values_to = \"model\") %>% \n  filter(map_lgl(model, ~ !is.null(.x$result))) %>%\n  mutate(model = map(model, \"result\"))\n```\n\n```{r bind-models-and-extract, include=TRUE, echo=TRUE}\n#| code-fold: true\n\n# function to extract coefficients with confidence intervals\nsafe_tidy <- possibly(\n  ~ broom.mixed::tidy(.x, conf.int = TRUE) %>% mutate(model_name = .y), \n  otherwise = NULL\n)\n\nmodels <- bind_rows(manual_models, ref_imp_models, ref_true_models, temp_test_models, global_models, best_models, parsimonious_models\n                    ) %>%\n  filter(!str_detect(model_name, exclude_type)) %>% \n  mutate(tidy = map2(model, model_name, safe_tidy), # extract coefficients and p-values\n         augment = map2(model, model_name, ~{ # extract fitted values, residuals, fixed effects without data that is not contained in the respective model\n           terms <- all.vars(formula(.x))[-1]  # Extract terms and remove response variable\n           broom.mixed::augment(.x) %>%\n           select(all_of(terms), METEO_ID, year, SPECIES_SHORT, .fitted, .resid, .fixed) %>%\n           mutate(model_name = .y)\n           }),\n         terms = map(model, ~all.vars(formula(.x))[-1]),\n         std_random = map(model, ~safely(~ {\n           intervals(.x)$reStruct %>%\n             unlist() %>%\n             as.data.frame() %>%\n             rename(VALUE = 1) %>%\n             rownames_to_column(\"PARAMETER\")})(.x)$result), # calculate and extract standard deviation of random effects\n         res_random = (res_random = map(model, ~.x$sigma)),\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE across populations\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         logLik = map(model, ~fun_get_log(.x)) # extract logLik\n         ) %>%\n  unnest(cAIC, logLik, RMSE) %>% \n    mutate(coef = map(model, ~coef(.x)),\n           terms_count = map(model, ~length(fixef(.x))+1), # extract number of parameters and add 1 for the grouping variable (for more details see Pinheiro and Bates 2000, p. 8)\n           RMSE = as.numeric(RMSE),\n           delta_total_cAIC = cAIC - min(cAIC))\n```\n\n```{r extract-results, include=TRUE, echo=TRUE}\n#| code-fold: true\n\n# extract RMSE\nselection_parameters <- models %>% \n  select(-tidy, -augment, -data, -terms) %>% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) %>% # extract random effects\n  select(model_name, RMSE, cAIC, logLik, terms_count, calls, fixed_effects, random_effects) %>%\n  unnest(RMSE, cAIC, logLik, terms_count) %>%\n  # add family and type\n  mutate(type = case_when(str_detect(model_name, \"temp_test\") ~ \"effect shape\",\n                          str_detect(model_name, \"ref_true\") ~ \"traditional reference\",\n                          str_detect(model_name, \"ref_imp\") ~ \"refined reference\",\n                          str_detect(model_name, \"final\") ~ \"final model\",\n                          str_detect(model_name, \"best\") ~ \"best model\",\n                          str_detect(model_name, \"global\") ~ \"global model\",\n                          str_detect(model_name, \"pars\") ~ \"parsimonious model\",\n                          TRUE ~ \"other\"),\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\")) %>%\n  mutate(d.cAIC_absolute = cAIC - min(cAIC)) %>% \n  group_by(family, type) %>%\n  # add delta value per group\n  mutate(d.cAIC_group = cAIC - min(cAIC),\n         d.RMSE_group = RMSE - min(RMSE)) %>% \n  ungroup()\n\n# extract coefficients and p-values\ntidy <- models %>% select(tidy) %>% unnest(tidy)\n\n# extract fitted, fixed and residuals\naugment <- models %>% select(augment) %>% unnest(augment)\n\n# extract standard deviation of random effects\nstd_random <- models %>% select(model_name, std_random) %>% unnest(std_random) %>% pivot_wider(names_from = PARAMETER, values_from = VALUE)\n\nres_random <- models %>% select(model_name, res_random) %>% mutate(res_random = as.numeric(res_random))\n```\n\n<!-- start:internal -->\n### Model overview\n\n```{r tbl-extract-calls, internal=TRUE}\n#| tbl-cap: Summary of model calls, fixed effects, random effects, RMSE and cAIC.\n\ndatatable(selection_parameters %>%\n            select(model_name, cAIC, logLik, RMSE, fixed_effects, random_effects) %>%\n            mutate_if(is.numeric, round, 2),  filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\n```\n\n```{r fig-plot-model-selection-parameters, fig.width=18, fig.height=8, fig.cap=\"Comparison of model selection parameters across models.\", internal=TRUE}\nplot <- ggplot(selection_parameters %>% pivot_longer(cols = c(cAIC, RMSE, logLik), names_to = \"selection_parameter\", values_to = \"value\"),\n       aes(x = model_name, y = value)) +\n  geom_point() +\nylab(\"Parameter value\") +\nxlab(\"Model name\") +\nfacet_wrap(~selection_parameter, scales = \"free_y\") +\ntheme_report(angle=90)\n\nggplotly(plot)\n```\n\n### Coefficients\n\n```{r tbl-coefficient-table}\n#| tbl-cap: Comparison of parameters across models with estimate, standard error, t-value and p-value.\n\ncoeff_table <- tidy %>%\n  mutate_if(is.numeric, signif, digits = 3) %>%\n  mutate(visual = case_when(estimate > 0 & p.value <= 0.05 ~ \"\\U1F87D\",\n                            estimate > 0 & p.value >= 0.05 ~ \"\\U1F865\",\n                            estimate < 0 & p.value <= 0.05 ~ \"\\U1F87E\",\n                            estimate < 0 & p.value >= 0.05 ~ \"\\U1F866\"),\n         category = label_fun_sim(term, \"category\"),\n         label = label_fun_sim(term, \"short\"),\n         SPECIES = species) %>%\n    select(category, label, model_name, visual, conf.low, estimate, conf.high, std.error, statistic, p.value, term, SPECIES)\n\nwrite_csv(coeff_table, paste0(path_output_data, \"/table_\", species, \"_\", gsub(\" \", \"_\", phase), \".csv\"))\n\ntable <- coeff_table %>%\n  select(-SPECIES) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\ntable\n```\n\n```{r fig-coefficient-plots, fig.height=20, fig.width=17, fig.cap=\"Coefficient estimate and standard error per term.\", internal = TRUE}\n#p <- \n  ggplot(coeff_table %>%\n         filter(!term %like% \"sd\",\n                !term %like% \"cor\") %>% \n         arrange(term) %>%\n         mutate(term = factor(term, levels = unique(term)),\n                significance = ifelse(p.value < 0.05, \"significant\", \"not significant\")),\n       aes(x=estimate, y=label)) +\n  geom_vline(xintercept=0, linetype=\"dashed\", size=1, colour=\"grey\") +\n  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.2, colour=\"grey\") +\n  geom_point(aes(colour = significance), shape=21, size=2) +\n  scale_colour_manual(values = c(\"significant\" = \"#008B00\", \"not significant\" = \"grey\")) +\n  guides(colour = guide_legend(title = NULL)) +\n  facet_wrap(~model_name, scales=\"fixed\", nrow=3) +\n  ylab(\"\")+\n  xlim(-500, 500) +\n  xlab(\"Estimate\")+\n  theme(panel.border = element_rect(color = \"grey\", fill = NA, size = 0.5))+\n  theme_report(hjust=0.5, legend.position = \"top\", angle=90)\n\n#ggplotly(p)\n```\n\n### Random effects\n\n```{r tbl-standard-deviation-random, internal = TRUE}\n#| tbl-cap: Standard deviation of random effects for each model.\n\ntable <- std_random %>%\n  mutate_if(is.numeric, signif, 3) %>%\n  datatable(rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5))\ntable\n```\n\n```{r fig-standard-deviation-random, fig.cap=\"Standard deviation of random effects for each model (nested random effects not shown).\", internal = TRUE}\nggplot(std_random, aes(x = model_name, y = METEO_ID.est., group = model_name)) +\n  geom_point() +\n  geom_errorbar(aes(ymin = METEO_ID.lower, ymax = METEO_ID.upper), width = 0.2) +\n  ylab(\"Standard deviation\") +\n  xlab(\"Model name\") +\n  theme_report(angle=90)\n```\n\n```{r tbl-residual-random, internal = TRUE}\n#| tbl-cap: Residual of random effects for each model.\n\ntable <- res_random %>%\n  mutate_if(is.numeric, signif, 3) %>%\n  datatable(rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5))\ntable\n```\n\n### Fitted/Fixed \\~ observed day of year\n\n```{r fig-predicted-vs-observed-scatter-all, fig.width=9, fig.height =4, fig.cap =\"Fitted ~ observed and Fixed ~ observed day of year for each model across SPN sites.\", internal = TRUE}\nggplot(data %>%\n         left_join(augment %>%\n                     select(METEO_ID, year, .fitted, .fixed, model_name), by=c(\"METEO_ID\", \"year\")) %>%\n         filter(str_detect(model_name, \"best|d2|ref_true|ref_imp_con_int$\") & !str_detect(model_name, \"slo\")) %>%\n         pivot_longer(cols=c(.fitted, .fixed), names_to=\"PARAMETER\", values_to = \"VALUE\")) +\n  geom_abline(slope = 1, intercept = 0, color = \"grey\", linetype = \"dashed\") +\n  geom_point(aes(y=VALUE, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.2)+\n  geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  #geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"lm\", se=FALSE)+\n  facet_wrap(~PARAMETER) +\n  ylab(\"Fitted/Fixed day of year\") +\n  xlab(\"Observed day of year\") +\n  theme_report(legend.position=\"top\", angle=90)\n```\n\n```{r fig-predicted-vs-observed-scatter-site, fig.height= 10, fig.width=8, fig.cap =\"Fitted ~ observed day of year for each model and SPN site.\", internal = TRUE}\nggplot(data %>% left_join(augment %>% select(METEO_ID, year, .fitted, .fixed, model_name), by=c(\"METEO_ID\", \"year\")) %>% filter(str_detect(model_name, \"_1|pars|ref_true\") & !str_detect(model_name, \"slo\"))) +\n  geom_abline(slope = 1, intercept = 0, color = \"grey\", linetype = \"dashed\") +\n  geom_point(aes(y=.fitted, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.2)+\n  geom_smooth(aes(y=.fitted, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  lims(x=c(95, 160), y=c(95, 160))+\n  facet_wrap(~METEO_ID, scale=\"fixed\", ncol=6)+\n  ylab(\"Fitted day of year\") +\n  xlab(\"Observed day of year\") +\n  theme_report(legend.position=\"top\", angle=90)\n```\n\n### Model selection\n\n```{r plot-tab-fun, internal=TRUE}\nplot_tab_fun <- function(filter_string){\n  selection_parameters %>%\n  arrange(family) %>% \n  select(model_name, family, cAIC, d.cAIC_group, RMSE, d.RMSE_group) %>%\n  filter(str_detect(model_name, paste0(filter_string))) %>%\n  mutate_if(is.numeric, round, 2) %>% \n  arrange(family, d.cAIC_group) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\n}\n```\n\n```{r tbl-delta-true, internal = TRUE}\n#| tbl-cap: Comparison of true reference models with cAIC and RMSE.\n\nplot_tab_fun(\"true\")\n```\n\n```{r tbl-delta-ref_imp, internal = TRUE}\n#| tbl-cap: Comparison of refined reference models with cAIC and RMSE.\n\nplot_tab_fun(\"ref_imp\")\n```\n\n```{r tbl-delta-best, internal = TRUE}\n#| tbl-cap: Comparison of best models with cAIC and RMSE.\n\nplot_tab_fun(\"best\")\n```\n\n```{r tbl-delta-pars, internal = TRUE}\n#| tbl-cap: Comparison of most parsimonious models with cAIC and RMSE.\n\nplot_tab_fun(\"pars\")\n```\n\n```{r tbl-delta-final, internal = TRUE}\n#| tbl-cap: Comparison of final models with cAIC and RMSE.\n\nplot_tab_fun(\"final\")\n```\n<!-- end:internal -->\n\n```{r save-output}\nsaveRDS(bind_rows(plot_weightd2, plot_weightd4) %>% ungroup(), paste0(path_output_data, \"/weights_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(con_var, paste0(path_output_data, \"/con_variations_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(results_temp_test %>% mutate(SPECIES_SHORT = species) %>% ungroup (), paste0(path_output_data, \"/results_temp_test_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(models %>% mutate(SPECIES_SHORT = species) %>% ungroup(), paste0(path_output_data, \"/models_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\naugment <- augment %>%  mutate(across(where(is.matrix), ~ .[,1]))\nsaveRDS(augment, paste0(path_output_data, \"/augment_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(selection_parameters %>% mutate(SPECIES_SHORT = species) %>% ungroup(), paste0(path_output_data, \"/selection_parameters_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n```\n","srcMarkdownNoYaml":"\n\n```{r parameters, include=FALSE, eval=TRUE}\nphase <- \"leaf unfolding\"\nspecies <- \"FS\"\n```\n\n# Fagus sylvatica\n\n```{r source-global, include=FALSE}\nlocation <- paste0(getwd())\nsource(paste0(\"../00_helpers/setup.R\")) #common libraries and custom functions\nsource(paste0(\"../00_helpers/species_and_phases.R\"))\n\nlib_results <- c(\n  \"nlme\",\n  \"MuMIn\",\n  \"cAIC4\",\n  \"lattice\",\n  \"broom.mixed\"\n  )\npackage_fun(lib_results, \"results1\")\n\n# type of temperature parametrization\nexclude_type <- \"mai\"\n\n# function to extract conditional LogLikelihood and return NA if failed\nfun_get_log <- function(x) {\n  tryCatch({\n    cAIC(x)$loglikelihood\n  }, error = function(e) {\n    NA # Return NA or some indication of failure for models that cause an error\n  })\n}\n```\n\n## Effect shape of temperature\n\n```{r load-temp-test}\ntemp_test <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^temp_test.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\ntemp_test_models <- temp_test %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r load-ref-true}\nref_true <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^ref_true.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\nref_true_models <- ref_true %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r load-ref-imp}\nref_imp <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^ref_imp.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\nref_imp_models <- ref_imp %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r bind-ref}\nall_ref <- bind_rows(temp_test_models, ref_true_models, ref_imp_models) %>%\n  filter(!str_detect(model_name, exclude_type),\n         !str_detect(model_name, \"slo\"))\n```\n\n```{r extract-temp-test}\nresults_temp_test <- all_ref %>%\n  mutate(tidy = map2(model, model_name, ~broom.mixed::tidy(.x) %>% mutate(model_name = .y)), # extract coefficients and p-values\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\"),\n         calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) # extract random effects\n```\n\n```{r format-selection}\nselection_param <- results_temp_test %>%\n  select(model_name, family, cAIC, RMSE, fixed_effects) %>%\n  unnest(RMSE, cAIC) %>%\n  group_by(family) %>%\n  mutate(d.cAIC = cAIC - min(cAIC),\n         d.RMSE = RMSE - min(RMSE))\n\ntidy <- results_temp_test %>%\n  select(tidy, family) %>%\n  unnest(tidy) %>%\n  mutate(label = label_fun(term)) %>%\n  select(model_name, label, family, p.value, estimate, std.error, term)\n```\n\n```{r tbl-temp-test-selection}\n#| tbl-cap: Comparison of model performance of linear and polynomial temperature parameters with cAIC and RMSE.\n\ntable <- selection_param %>%\n  filter(!model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 3) %>%\n  arrange(family, d.cAIC) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip', buttons = \"print\"), rownames=FALSE)\ntable\n```\n\n```{r tbl-temp-test-coefficients}\n#| tbl-cap: Comparison of parameters across models with estimate, standard error, t-value and p-value\n  \ntable <- tidy %>%\n  filter(!model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 4) %>%\n  filter(!str_detect(term, \"Intercept|Observation|sd\"),\n         str_detect(model_name, \"temp_test\")) %>%\n  arrange(family) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n## Effect shape of temperature with chilling\n\n```{r tbl-shape-performance}\n#| tbl-cap: Comparison of model performance of linear and non-linear growing degree days in combination with chilling degree days. \n\ntable <- selection_param %>%\n  filter(model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 3) %>%\n  arrange(family, d.cAIC) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip', buttons = \"print\"), rownames=FALSE)\ntable\n```\n\n```{r tbl-shape-coefficients}\n#| tbl-cap: Comparison of siginificance of various growing and chilling degree day combinations.\n\ntable <- tidy %>%\n  filter(model_name %like% \"imp\") %>% \n  mutate_if(is.numeric, round, 4) %>%\n  filter(!str_detect(term, \"Intercept|Observation|sd\")) %>%\n  arrange(family) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n## Global model variations\n\n```{r load-objects}\nall_models <- list.files(path = paste0(path_output_data),\n                    pattern = sprintf(\"^dredge_(.*?)_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                    full.names = TRUE) %>%\n  setNames(gsub(\"^dredge_(.*?)\\\\.rds\", \"\\\\1\", basename(.))) %>%\n  lapply(readRDS)\n```\n\n<!-- start:internal -->\n\n### Model variations\n<!-- end:internal -->\n\n```{r extract-model-variations}\nvariations_d4 <- map_df(all_models, ~ .x[[\"dredge_result_d4\"]] %>%\n                          as.data.frame() %>%\n                          mutate(model_name=.x[[\"model_name\"]]) %>%\n                          mutate_if(is.numeric, signif, 3) %>%\n                          select(model_name, cAIC, delta, weight, RMSE, logLik, `(Intercept)`, contains(\"GDD\"), everything()) %>%\n                          filter(!str_detect(model_name, exclude_type)))\n\nvariations_d2 <- map_df(all_models, ~ .x[[\"dredge_result_d2\"]] %>%\n                          as.data.frame() %>%\n                          mutate(model_name=.x[[\"model_name\"]]) %>%\n                          mutate_if(is.numeric, signif, 3) %>%\n                          select(model_name, cAIC, delta, weight, RMSE, logLik, `(Intercept)`, contains(\"GDD\"), everything()) %>%\n                          filter(!str_detect(model_name, exclude_type)))\n```\n\n```{r tbl-d4-models, internal=TRUE}\n#| tbl-cap: Model variations of the global model with delta cAIC < 4. A \"+\" means the term is included but the estimate is not shown.\n\ntable <- variations_d4 %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 5), rownames=FALSE)\ntable\n```\n\n```{r tbl-d2-models, internal=TRUE}\n#| tbl-cap: Model variations of the global model with the delta cAIC < 2. A \"+\" means the term is included but the estimate is not shown.\n\ntable <- variations_d2 %>%\n  datatable(filter = 'top', rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5))\ntable\n```\n\n```{r failed-variations1, include=FALSE, internal = TRUE}\nmod <- all_models[[1]][[\"dredge_result\"]]\n\ncoef_tables <- attr(mod, \"coefTables\")\ncoef_lengths <- lapply(coef_tables, function(table) nrow(table) - 1) # +1 for the grouping variable\ncoef_lengths <- unlist(coef_lengths)\nmod$coef_lengths <- coef_lengths\n\nggplot() +\n  geom_boxplot(data=mod %>% filter(!is.na(cAIC)), aes(x = \"completed\", y = coef_lengths)) +\n  geom_boxplot(data=mod %>% filter(is.na(cAIC)), aes(x = \"failed\", y = coef_lengths), color=\"red\")+\n  xlab(\"\")+\n  ylab(\"Number of coefficients\")+\n  theme_report(hjust=0.5)\n\nmin_expected <- 2^11 \nmin_expected\n```\n\n```{r failed-variations2, fig.height=8, fig.width=8, fig.cap=\"Failed conservative models due to 'Fehler bei der Auswertung des Argumentes 'x' bei der Methodenauswahl für Funktion 'chol': System ist für den Rechner singulär: reziproke Konditionszahl' while calculating the cAIC.\", internal = TRUE}\n\ncompleted <- mod %>%\n  as.data.frame() %>%\n  mutate(status = case_when(!is.na(cAIC) ~ \"completed\",\n                            TRUE ~ \"failed\")) %>%\n  group_by(status) %>%\n  summarize(across(-coef_lengths, ~ sum(!is.na(.))),\n            total=n(),\n            mean_coeff = mean(coef_lengths, na.rm = TRUE),\n            max_coeff = max(coef_lengths, na.rm = TRUE)) %>%\n  ungroup() %>%\n  mutate(total_all = sum(total),\n         rate = total / total_all * 100)\n\nsaveRDS(completed %>% ungroup(), paste0(path_own_data, \"/output_data/failed_\", species, \"_\", phase, \".rds\"))\n\n# Convert to long format for ggplot\ncomparison_long <- completed %>%\n  select(-matches(\"(Inter|cAIC|df|delta|weight|log|name|RMSE|rate|total|coeff)\")) %>%\n  pivot_longer(cols = -status, names_to = \"parameter\", values_to = \"count\") %>%\n  mutate(parameter=label_fun(parameter))\n\n# Plot\nggplot(comparison_long, aes(x = parameter, y = count, fill = status)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  geom_text(aes(label = count), position = position_stack(vjust = 0.5), size = 3) +\n  #annotate(\"text\", x = 6, y = 2000, label = paste0(\"Failure rate \", round(ratio, 0), \"%\"), vjust = -1, hjust = 0) +\n  ylab(\"Number of models with parameter\") +\n  xlab(\"\")+\n  theme_report(angle = -90)\n```\n\n```{r tbl-variations}\n#| tbl-cap: Number of equally or almost equally informative conservative model variations and maximum model weights (Δ cAIC < 4 and < 2).\n\n# weight_checkd4 <- variations_d4 %>% group_by(model_name) %>% summarize(weight_sum = sum(weight))\n# weight_checkd2 <- variations_d2 %>% group_by(model_name) %>% summarize(weight_sum = sum(weight))\n\nweightd2 <- variations_d2 %>%\n  filter(!str_detect(model_name, exclude_type)) %>%\n  summarize(max_weight2 = max(weight))\n\nweightd4 <- variations_d4 %>%\n  filter(!str_detect(model_name, exclude_type)) %>%\n  summarize(max_weight4 = max(weight))\n\n# summarize conservative model variations\ncon_var <- variations_d4 %>%\n  filter(!str_detect(model_name, exclude_type)) %>%\n  summarize(SPECIES_SHORT = species,\n            d4 = sum(delta <4),\n            d2 = sum(delta <2)) %>%\n  bind_cols(weightd4, weightd2)\n\ntable <- con_var %>%\n  select(-SPECIES_SHORT) %>%\n  datatable(rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5),\n            colnames = c('number of models (Δ < 4)' = \"d4\",\n                         'number of models (Δ < 2)' = \"d2\",\n                         'maximum weight (Δ < 4)' = \"max_weight4\",\n                         'maximum weight (Δ < 2)' = \"max_weight2\"))\ntable\n```\n\n```{r tbl-best-models}\n#| tbl-cap: The three best model variations derived from the global model.\nbest <- list.files(path = paste0(path_output_data),\n                   pattern = sprintf(\"^best_(.*?)_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n    setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS)\n\nbest_models <- best %>%\n  flatten() %>%\n  rbind() %>%\n  as.data.frame() %>% \n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n\nbest_calls <- best_models %>% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) %>% # extract random effects\n  select(model_name, fixed_effects, random_effects)\n\nbest_calls %>%\n  select(-random_effects) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 5, dom = 'Bfrtip'), rownames=FALSE)\n```\n\n```{r tbl-parsimonious-con}\n#| tbl-cap: The three most parsimonious models derived from the global model.\nparsimonious_models <- map(all_models, ~ keep(.x, .p = str_detect(names(.x), \"parsimonious\"))) %>%\n  list_flatten() %>% # flatten list two times\n  list_flatten() %>%\n  enframe() %>%\n  rename(model = value, model_name = name) %>%\n  mutate(model_name = case_when(model_name %like% \"con\" & model_name %like% \"d4\" ~ \"parsimonious_con_d4\",\n                                model_name %like% \"con\" & model_name %like% \"d2\" ~ \"parsimonious_con_d2\",\n                                model_name %like% \"mai\" & model_name %like% \"d4\" ~ \"parsimonious_mai_d4\",\n                                model_name %like% \"mai\" & model_name %like% \"d2\" ~ \"parsimonious_mai_d2\",\n                                TRUE ~ model_name)) %>%\n  group_by(model_name) %>%\n  mutate(suffix = letters[row_number()]) %>%\n  ungroup() %>% \n  mutate(model_name = paste0(model_name, suffix)) %>%\n  filter(!str_detect(model_name, exclude_type))\n  \nparsimonious_calls <- parsimonious_models %>% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) %>% # extract random effects\n  select(model_name, fixed_effects, random_effects)\n\nparsimonious_calls %>%\n  select(-random_effects) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 5, dom = 'Bfrtip'), rownames=FALSE)\n```\n\n<!-- start:internal -->\n\n### Parameter weights\n<!-- end:internal -->\n\n```{r format-weights, echo=FALSE}\nplot_weightd4 <- map_df(all_models, ~ as.data.frame(as.matrix(.x$summary_weight_d4)), .id = \"model_id\") %>%\n  mutate(WEIGHT=as.numeric(WEIGHT),\n         category = category_fun(PARAMETER),\n         PARAMETER_ABBR = label_fun_sim(PARAMETER, \"short\"),\n         PARAMETER = label_fun_sim(PARAMETER, \"full\"),\n         DELTA = \"D4\") %>%\n  filter(!str_detect(model_id, exclude_type))\n\nplot_weightd2 <- map_df(all_models, ~ as.data.frame(as.matrix(.x$summary_weight_d2)), .id = \"model_id\") %>%\n  mutate(WEIGHT=as.numeric(WEIGHT),\n         category = category_fun(PARAMETER),\n         PARAMETER_ABBR = label_fun_sim(PARAMETER, \"short\"),\n         PARAMETER = label_fun_sim(PARAMETER, \"full\"),\n         DELTA = \"D2\") %>%\n  filter(!str_detect(model_id, exclude_type))\n```\n\n```{r fig-mumln-weights-d4, fig.width=15, fig.height=8, fig.cap=\"Sum of model weights (relative importance value) over models with delta cAIC < 4.\", internal = TRUE}\nggplot(plot_weightd4, aes(x = model_id, y = PARAMETER_ABBR, fill=WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.8, limit = c(0, 1), na.value = NA) +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"Model\") +\n  ylab(\"Parameter\") +\n  theme_report()+\n  theme(axis.text.x = element_text(hjust = 0.5))\n```\n\n```{r fig-mumln-weight-d2, fig.width= 15, fig.height=8, fig.cap=\"Sum of model weights (relative importance value) over models with delta cAIC < 2.\", internal = TRUE}\nggplot(plot_weightd2, aes(x = model_id, y = PARAMETER_ABBR, fill=WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.8, limit = c(0, 1), na.value = NA) +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"Model\") +\n  ylab(\"Parameter\") +\n  theme_report()+\n  theme(axis.text.x = element_text(hjust = 0.5))\n```\n\n```{r rm-large-objects}\nrm(all_models)\ninvisible(gc(verbose = FALSE))\n```\n\n## Model processing\n\n```{r load-data}\ndata <- readRDS(paste0(path_own_data, \"/data_unscaled_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\")) %>%\n  rename_fun() %>%\n  select(-LEAF_COLOURING_LAG) %>%\n  mutate(METEO_ID = factor(METEO_ID),\n         RELIEF = factor(RELIEF),\n         SOCIAL_SITUATION = factor(SOCIAL_SITUATION),\n         EDGE_DIST_IMPUTED = factor(EDGE_DIST_IMPUTED))\n```\n\n```{r load-temporal-correlation}\nautoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\nrandom_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n```\n\n```{r load-reference-refined}\nref_imp <- list.files(path = paste0(path_output_data),\n                        pattern = sprintf(\"^ref_imp.*_%s_%s\\\\.rds$\", species, gsub(\" \", \"_\", phase)),\n                   full.names = TRUE) %>%\n  lapply(readRDS)\n\nref_imp_models <- ref_imp %>%\n  list_flatten() %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r load-global-models, include=FALSE}\nglobal <- list.files(path = paste0(path_output_data),\n                     pattern = paste0(\"global.*_\", species, \"_\", gsub(\" \", \"_\", phase), \"\\\\.rds$\"),\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS)\n\nglobal_models <- global %>%\n  rbind() %>%\n  as.data.frame() %>%\n  pivot_longer(cols = 1:ncol(.), names_to = \"model_name\", values_to = \"model\") %>%\n  filter(!str_detect(model_name, exclude_type))\n```\n\n```{r species-specific-manual-models, echo=TRUE}\n# nest data set\nmanual_models_input <- data %>%\n  nest()\n\n# save to file for evaluation of manual models in the template\nsaveRDS(manual_models_input, paste0(path_output_data, \"/manual_models_\", species, \"_\", gsub (\" \", \"_\", phase), \".rds\"))\n\n# source manual models to be evaluated within template\nsource(paste0(location, \"/5_manual_\", species, \"_\", gsub (\" \", \"_\", phase), \".R\"), echo=TRUE, max.deparse.length = 5000)\n\n# format manual models to fit the data frame structure\nmanual_models <- manual_models %>%\n  pivot_longer(cols = 2:ncol(.), names_to = \"model_name\", values_to = \"model\") %>% \n  filter(map_lgl(model, ~ !is.null(.x$result))) %>%\n  mutate(model = map(model, \"result\"))\n```\n\n```{r bind-models-and-extract, include=TRUE, echo=TRUE}\n#| code-fold: true\n\n# function to extract coefficients with confidence intervals\nsafe_tidy <- possibly(\n  ~ broom.mixed::tidy(.x, conf.int = TRUE) %>% mutate(model_name = .y), \n  otherwise = NULL\n)\n\nmodels <- bind_rows(manual_models, ref_imp_models, ref_true_models, temp_test_models, global_models, best_models, parsimonious_models\n                    ) %>%\n  filter(!str_detect(model_name, exclude_type)) %>% \n  mutate(tidy = map2(model, model_name, safe_tidy), # extract coefficients and p-values\n         augment = map2(model, model_name, ~{ # extract fitted values, residuals, fixed effects without data that is not contained in the respective model\n           terms <- all.vars(formula(.x))[-1]  # Extract terms and remove response variable\n           broom.mixed::augment(.x) %>%\n           select(all_of(terms), METEO_ID, year, SPECIES_SHORT, .fitted, .resid, .fixed) %>%\n           mutate(model_name = .y)\n           }),\n         terms = map(model, ~all.vars(formula(.x))[-1]),\n         std_random = map(model, ~safely(~ {\n           intervals(.x)$reStruct %>%\n             unlist() %>%\n             as.data.frame() %>%\n             rename(VALUE = 1) %>%\n             rownames_to_column(\"PARAMETER\")})(.x)$result), # calculate and extract standard deviation of random effects\n         res_random = (res_random = map(model, ~.x$sigma)),\n         RMSE = map(model, ~sqrt(mean(.x$residuals^2))), # extract RMSE across populations\n         cAIC = map(model, ~fun_get_caic(.x)), # extract cAIC\n         logLik = map(model, ~fun_get_log(.x)) # extract logLik\n         ) %>%\n  unnest(cAIC, logLik, RMSE) %>% \n    mutate(coef = map(model, ~coef(.x)),\n           terms_count = map(model, ~length(fixef(.x))+1), # extract number of parameters and add 1 for the grouping variable (for more details see Pinheiro and Bates 2000, p. 8)\n           RMSE = as.numeric(RMSE),\n           delta_total_cAIC = cAIC - min(cAIC))\n```\n\n```{r extract-results, include=TRUE, echo=TRUE}\n#| code-fold: true\n\n# extract RMSE\nselection_parameters <- models %>% \n  select(-tidy, -augment, -data, -terms) %>% \n  mutate(calls = map(model, ~deparse(.x[[\"call\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract calls\n         fixed_effects = map(model, ~deparse(.x[[\"terms\"]]) %>% paste(collapse = \" \")) %>% as.character(), # extract fixed effects\n         random_effects = map(model, ~.x[[\"call\"]][[\"random\"]]) %>% as.character()) %>% # extract random effects\n  select(model_name, RMSE, cAIC, logLik, terms_count, calls, fixed_effects, random_effects) %>%\n  unnest(RMSE, cAIC, logLik, terms_count) %>%\n  # add family and type\n  mutate(type = case_when(str_detect(model_name, \"temp_test\") ~ \"effect shape\",\n                          str_detect(model_name, \"ref_true\") ~ \"traditional reference\",\n                          str_detect(model_name, \"ref_imp\") ~ \"refined reference\",\n                          str_detect(model_name, \"final\") ~ \"final model\",\n                          str_detect(model_name, \"best\") ~ \"best model\",\n                          str_detect(model_name, \"global\") ~ \"global model\",\n                          str_detect(model_name, \"pars\") ~ \"parsimonious model\",\n                          TRUE ~ \"other\"),\n         family = case_when(str_detect(model_name, \"con\") ~ \"conservative\",\n                            str_detect(model_name, \"mai\") ~ \"mainstream\",\n                            TRUE ~ \"other\")) %>%\n  mutate(d.cAIC_absolute = cAIC - min(cAIC)) %>% \n  group_by(family, type) %>%\n  # add delta value per group\n  mutate(d.cAIC_group = cAIC - min(cAIC),\n         d.RMSE_group = RMSE - min(RMSE)) %>% \n  ungroup()\n\n# extract coefficients and p-values\ntidy <- models %>% select(tidy) %>% unnest(tidy)\n\n# extract fitted, fixed and residuals\naugment <- models %>% select(augment) %>% unnest(augment)\n\n# extract standard deviation of random effects\nstd_random <- models %>% select(model_name, std_random) %>% unnest(std_random) %>% pivot_wider(names_from = PARAMETER, values_from = VALUE)\n\nres_random <- models %>% select(model_name, res_random) %>% mutate(res_random = as.numeric(res_random))\n```\n\n<!-- start:internal -->\n### Model overview\n\n```{r tbl-extract-calls, internal=TRUE}\n#| tbl-cap: Summary of model calls, fixed effects, random effects, RMSE and cAIC.\n\ndatatable(selection_parameters %>%\n            select(model_name, cAIC, logLik, RMSE, fixed_effects, random_effects) %>%\n            mutate_if(is.numeric, round, 2),  filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\n```\n\n```{r fig-plot-model-selection-parameters, fig.width=18, fig.height=8, fig.cap=\"Comparison of model selection parameters across models.\", internal=TRUE}\nplot <- ggplot(selection_parameters %>% pivot_longer(cols = c(cAIC, RMSE, logLik), names_to = \"selection_parameter\", values_to = \"value\"),\n       aes(x = model_name, y = value)) +\n  geom_point() +\nylab(\"Parameter value\") +\nxlab(\"Model name\") +\nfacet_wrap(~selection_parameter, scales = \"free_y\") +\ntheme_report(angle=90)\n\nggplotly(plot)\n```\n\n### Coefficients\n\n```{r tbl-coefficient-table}\n#| tbl-cap: Comparison of parameters across models with estimate, standard error, t-value and p-value.\n\ncoeff_table <- tidy %>%\n  mutate_if(is.numeric, signif, digits = 3) %>%\n  mutate(visual = case_when(estimate > 0 & p.value <= 0.05 ~ \"\\U1F87D\",\n                            estimate > 0 & p.value >= 0.05 ~ \"\\U1F865\",\n                            estimate < 0 & p.value <= 0.05 ~ \"\\U1F87E\",\n                            estimate < 0 & p.value >= 0.05 ~ \"\\U1F866\"),\n         category = label_fun_sim(term, \"category\"),\n         label = label_fun_sim(term, \"short\"),\n         SPECIES = species) %>%\n    select(category, label, model_name, visual, conf.low, estimate, conf.high, std.error, statistic, p.value, term, SPECIES)\n\nwrite_csv(coeff_table, paste0(path_output_data, \"/table_\", species, \"_\", gsub(\" \", \"_\", phase), \".csv\"))\n\ntable <- coeff_table %>%\n  select(-SPECIES) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\ntable\n```\n\n```{r fig-coefficient-plots, fig.height=20, fig.width=17, fig.cap=\"Coefficient estimate and standard error per term.\", internal = TRUE}\n#p <- \n  ggplot(coeff_table %>%\n         filter(!term %like% \"sd\",\n                !term %like% \"cor\") %>% \n         arrange(term) %>%\n         mutate(term = factor(term, levels = unique(term)),\n                significance = ifelse(p.value < 0.05, \"significant\", \"not significant\")),\n       aes(x=estimate, y=label)) +\n  geom_vline(xintercept=0, linetype=\"dashed\", size=1, colour=\"grey\") +\n  geom_errorbar(aes(xmin=estimate-std.error, xmax=estimate+std.error), width=.2, colour=\"grey\") +\n  geom_point(aes(colour = significance), shape=21, size=2) +\n  scale_colour_manual(values = c(\"significant\" = \"#008B00\", \"not significant\" = \"grey\")) +\n  guides(colour = guide_legend(title = NULL)) +\n  facet_wrap(~model_name, scales=\"fixed\", nrow=3) +\n  ylab(\"\")+\n  xlim(-500, 500) +\n  xlab(\"Estimate\")+\n  theme(panel.border = element_rect(color = \"grey\", fill = NA, size = 0.5))+\n  theme_report(hjust=0.5, legend.position = \"top\", angle=90)\n\n#ggplotly(p)\n```\n\n### Random effects\n\n```{r tbl-standard-deviation-random, internal = TRUE}\n#| tbl-cap: Standard deviation of random effects for each model.\n\ntable <- std_random %>%\n  mutate_if(is.numeric, signif, 3) %>%\n  datatable(rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5))\ntable\n```\n\n```{r fig-standard-deviation-random, fig.cap=\"Standard deviation of random effects for each model (nested random effects not shown).\", internal = TRUE}\nggplot(std_random, aes(x = model_name, y = METEO_ID.est., group = model_name)) +\n  geom_point() +\n  geom_errorbar(aes(ymin = METEO_ID.lower, ymax = METEO_ID.upper), width = 0.2) +\n  ylab(\"Standard deviation\") +\n  xlab(\"Model name\") +\n  theme_report(angle=90)\n```\n\n```{r tbl-residual-random, internal = TRUE}\n#| tbl-cap: Residual of random effects for each model.\n\ntable <- res_random %>%\n  mutate_if(is.numeric, signif, 3) %>%\n  datatable(rownames=FALSE, options = list(scrollX = TRUE, pageLength = 5))\ntable\n```\n\n### Fitted/Fixed \\~ observed day of year\n\n```{r fig-predicted-vs-observed-scatter-all, fig.width=9, fig.height =4, fig.cap =\"Fitted ~ observed and Fixed ~ observed day of year for each model across SPN sites.\", internal = TRUE}\nggplot(data %>%\n         left_join(augment %>%\n                     select(METEO_ID, year, .fitted, .fixed, model_name), by=c(\"METEO_ID\", \"year\")) %>%\n         filter(str_detect(model_name, \"best|d2|ref_true|ref_imp_con_int$\") & !str_detect(model_name, \"slo\")) %>%\n         pivot_longer(cols=c(.fitted, .fixed), names_to=\"PARAMETER\", values_to = \"VALUE\")) +\n  geom_abline(slope = 1, intercept = 0, color = \"grey\", linetype = \"dashed\") +\n  geom_point(aes(y=VALUE, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.2)+\n  geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  #geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"lm\", se=FALSE)+\n  facet_wrap(~PARAMETER) +\n  ylab(\"Fitted/Fixed day of year\") +\n  xlab(\"Observed day of year\") +\n  theme_report(legend.position=\"top\", angle=90)\n```\n\n```{r fig-predicted-vs-observed-scatter-site, fig.height= 10, fig.width=8, fig.cap =\"Fitted ~ observed day of year for each model and SPN site.\", internal = TRUE}\nggplot(data %>% left_join(augment %>% select(METEO_ID, year, .fitted, .fixed, model_name), by=c(\"METEO_ID\", \"year\")) %>% filter(str_detect(model_name, \"_1|pars|ref_true\") & !str_detect(model_name, \"slo\"))) +\n  geom_abline(slope = 1, intercept = 0, color = \"grey\", linetype = \"dashed\") +\n  geom_point(aes(y=.fitted, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.2)+\n  geom_smooth(aes(y=.fitted, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  lims(x=c(95, 160), y=c(95, 160))+\n  facet_wrap(~METEO_ID, scale=\"fixed\", ncol=6)+\n  ylab(\"Fitted day of year\") +\n  xlab(\"Observed day of year\") +\n  theme_report(legend.position=\"top\", angle=90)\n```\n\n### Model selection\n\n```{r plot-tab-fun, internal=TRUE}\nplot_tab_fun <- function(filter_string){\n  selection_parameters %>%\n  arrange(family) %>% \n  select(model_name, family, cAIC, d.cAIC_group, RMSE, d.RMSE_group) %>%\n  filter(str_detect(model_name, paste0(filter_string))) %>%\n  mutate_if(is.numeric, round, 2) %>% \n  arrange(family, d.cAIC_group) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\n}\n```\n\n```{r tbl-delta-true, internal = TRUE}\n#| tbl-cap: Comparison of true reference models with cAIC and RMSE.\n\nplot_tab_fun(\"true\")\n```\n\n```{r tbl-delta-ref_imp, internal = TRUE}\n#| tbl-cap: Comparison of refined reference models with cAIC and RMSE.\n\nplot_tab_fun(\"ref_imp\")\n```\n\n```{r tbl-delta-best, internal = TRUE}\n#| tbl-cap: Comparison of best models with cAIC and RMSE.\n\nplot_tab_fun(\"best\")\n```\n\n```{r tbl-delta-pars, internal = TRUE}\n#| tbl-cap: Comparison of most parsimonious models with cAIC and RMSE.\n\nplot_tab_fun(\"pars\")\n```\n\n```{r tbl-delta-final, internal = TRUE}\n#| tbl-cap: Comparison of final models with cAIC and RMSE.\n\nplot_tab_fun(\"final\")\n```\n<!-- end:internal -->\n\n```{r save-output}\nsaveRDS(bind_rows(plot_weightd2, plot_weightd4) %>% ungroup(), paste0(path_output_data, \"/weights_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(con_var, paste0(path_output_data, \"/con_variations_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(results_temp_test %>% mutate(SPECIES_SHORT = species) %>% ungroup (), paste0(path_output_data, \"/results_temp_test_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(models %>% mutate(SPECIES_SHORT = species) %>% ungroup(), paste0(path_output_data, \"/models_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\naugment <- augment %>%  mutate(across(where(is.matrix), ~ .[,1]))\nsaveRDS(augment, paste0(path_output_data, \"/augment_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n\nsaveRDS(selection_parameters %>% mutate(SPECIES_SHORT = species) %>% ungroup(), paste0(path_output_data, \"/selection_parameters_\", species, \"_\", gsub(\" \", \"_\", phase), \".rds\"))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":4,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":"html_document","warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"espresso","toc":true,"toc-depth":3,"include-in-header":{"text":"<script type=\"text/javascript\" src=\"C:/Users/iostovary/Documents/Data/00_helpers/zoom.js\"></script>"},"output-file":"5_results_FS_leaf_unfolding.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","bibliography":["C:/Users/iostovary/Documents/Data/references.bib"],"csl":"C:/Users/iostovary/Documents/Data/citation_style_global-ecology-and-biogeography_mod_ostovary.csl","editor":"visual","page-layout":"full","code-summary":"Show the code","theme":"minty","code-folding":"hide","grid":{"body-width":"1100px"},"toc-location":"right","toc-float":{"collapsed":false,"number-sections":true},"editor_options":{"chunk_output_type":"inline"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}