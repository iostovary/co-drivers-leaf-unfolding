{"title":"Species comparison","markdown":{"yaml":{"output":"html_document","editor_options":{"chunk_output_type":"inline"},"execute":{"freeze":false}},"headingText":"Species comparison","containsRefs":false,"markdown":"\n\n\n```{r source, include=FALSE}\nlocation <- paste0(getwd())\nsource(paste0(\"../00_helpers/setup.R\")) #common libraries and custom functions\nsource(paste0(\"../00_helpers/species_and_phases.R\"))\n\nlib_results <- c(\n  \"ggeffects\",\n  \"nlme\",\n  \"cowplot\",\n  \"ggtext\",\n  \"ggh4x\" # nested facets\n  )\npackage_fun(lib_results, \"results2\")\n\ntype <- \"con\"\n```\n\n```{r load-table, include=FALSE}\ncoeff_table <- list.files(path = paste0(path_output_data),\n                     pattern = \"^table.*\\\\.csv$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(read.csv) %>% \n  bind_rows() %>%\n  unite(\"GROUP\", model_name, SPECIES, sep=\"_\", remove=FALSE)\n```\n\n```{r format-p-table}\np_table <- coeff_table %>% \n  mutate(SPECIES_SHORT = SPECIES,\n         SPECIES = recode(SPECIES_SHORT, !!!rename_species_en),\n         label = label_fun_sim(term, \"short\"),\n         PARAMETER = label) %>% \n  arrange(SPECIES,\n          str_detect(term, \"sd_\"),\n          str_detect(term, \"Intercept\"),\n          str_detect(term, \"TREE_HEIGHT\"),\n          str_detect(term, \"DROUGHT\"),\n          str_detect(term, \"ELEVATION\"),\n          str_detect(term, \":\"),\n          str_detect(term, \"CDD\"),\n          str_detect(term, \"GDD\"),\n          term) %>% \n  mutate(across(where(is.numeric), ~ round(.x, 3))) %>%\n  mutate(p.value = as.character(p.value),\n         p.value = case_when(p.value == 0.000 ~ \"‚â§ 0.001\",\n                             TRUE ~ p.value))\n\nsaveRDS(p_table, paste0(path_output_data, \"/p_table.rds\"))\n\np_table_test <- p_table %>%\n    filter(str_detect(model_name, paste0(\"temp_test_con_int\")))\n\np_table_refined <- p_table %>%\n    filter(str_detect(model_name, paste0(\"ref_imp_con_int$\")))\n\np_table_parsimonious <- p_table %>% \n    filter(str_detect(model_name, paste0(\"parsimonious_con_d2\")))\n\np_table <- p_table %>%\n    filter(str_detect(model_name, paste0(\"best_con_1\")))\n```\n\n```{r load-augment}\naugment <- list.files(path = paste0(path_output_data),\n                     pattern = \"^augment.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>% \n  unite(\"GROUP\", model_name, SPECIES_SHORT, sep=\"_\", remove=FALSE) %>%\n  filter(str_detect(model_name, paste0(type)))\n```\n\n```{r load-data}\ndata_unscaled <- list.files(path = paste0(path_own_data),\n                     pattern = \"^data_unscaled.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows()\n```\n\n```{r load-selection-parameters}\nselection_parameters <- list.files(path = paste0(path_output_data),\n                     pattern = \"^selection_parameters.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>% \n  filter(model_name %like% \"con\") %>%\n  mutate(type = case_when(model_name %like% \"parsimonious.*a\" ~ \"parsimonious 1\",\n                          model_name %like% \"parsimonious.*b\" ~ \"parsimonious 2\",\n                          model_name %like% \"parsimonious.*c\" ~ \"parsimonious 3\",\n                          TRUE ~ type))\n```\n\n```{r load-con-variations-summary}\ncon_var <- list.files(path = paste0(path_output_data),\n                      pattern = \"^con_variations_.*\\\\.rds$\",\n                      full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[3:3], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows()\n```\n\n```{r load-weights}\nweights_raw <- list.files(path = paste0(path_output_data),\n                     pattern = \"^weights_.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>%\n  filter(str_detect(MODEL, paste0(type)))\n```\n\n```{r fun-format-equations}\nlabel_stats_fun <- function(term) {\n  # strip doy\n  term <- str_replace_all(term, \"doy ~\", \"\")\n  # strip 1\n  term <- str_replace_all(term, \"\\\\+\\\\s*1\", \"\")\n  term <- str_replace_all(term, \"1\\\\s*\\\\+\", \"\")\n  \n  # Correctly format interactions (replace * and separate interaction terms)\n  term <- str_replace_all(term, \"\\\\:\", \" * \")  \n  \n  # Remove ', degree = 2' with flexible spaces\n  term <- str_replace_all(term, \",\\\\s*degree\\\\s*=\\\\s*2\", \"\")\n\n  # Remove trailing '1' or '2' after the closing parenthesis\n  term <- str_replace_all(term, \"\\\\)\\\\s*[12]\", \")\")\n  \n  # Replace specific variables with formatted labels\n  term <- str_replace_all(term, \"CLIM_BALANCE\", \"CWB\")\n  term <- str_replace_all(term, \"CDD_conservative\", \"CDD\")\n  term <- str_replace_all(term, \"CDD_mainstream\", \"CDD\")\n  term <- str_replace_all(term, \"GDD_conservative\", \"GDD\")\n  term <- str_replace_all(term, \"GDD_mainstream\", \"GDD\")\n  term <- str_replace_all(term, \"TREE_ELEVATION\", \"Elevation\")\n  term <- str_replace_all(term, \"TREE_HEIGHT\", \"Tree height\")\n  term <- str_replace_all(term, \"STAND_HEIGHT\", \"Stand height\")\n  term <- str_replace_all(term, \"EDGE_DISTANCE_IMPUTED\", \"Distance forest edge imputed\")\n  term <- str_replace_all(term, \"EDGE_DIST\", \"Distance forest edge\")\n  term <- str_replace_all(term, \"SLOPE_ASPECT_HL\", \"Slope aspect\")\n  term <- str_replace_all(term, \"SLOPE_INCLINATION_DEG\", \"Slope inclination\")\n  term <- str_replace_all(term, \"DROUGHT\", \"CWB\")\n  term <- str_replace_all(term, \"AWC\", \"AWC\")\n  term <- str_replace_all(term, \"RELIEF\", \"Relief\")\n  term <- str_replace_all(term, \"SOCIAL_SITUATION\", \"Social position\")\n  term <- str_replace_all(term, \"METEO_ID\", \"Site\")\n  term <- str_squish(term)\n  term\n}\n\nrearrange_terms <- function(expression) {\n  terms <- unlist(strsplit(expression, \" \\\\+ \")) |> trimws()\n\n  interaction_terms <- terms[str_detect(terms, \"\\\\s*\\\\*\\\\s*\")]\n\n  temp_interaction_terms <- keep(interaction_terms, ~ str_detect(.x, \"GDD|CDD\"))\n  env_interaction_terms <- setdiff(interaction_terms, temp_interaction_terms)\n\n  other_terms <- setdiff(terms, interaction_terms)\n  all_interaction_terms <- c(temp_interaction_terms, env_interaction_terms)\n  other_terms <- keep(other_terms, ~ !any(str_detect(all_interaction_terms, fixed(.x))))\n\n  gdd_terms <- keep(other_terms, ~ str_detect(.x, \"GDD\"))\n  cdd_terms <- keep(other_terms, ~ str_detect(.x, \"CDD\"))\n\n  other_terms_clean <- setdiff(other_terms, c(gdd_terms, cdd_terms))\n\n  reordered_terms <- c(gdd_terms, cdd_terms, temp_interaction_terms, other_terms_clean, env_interaction_terms)\n  paste(reordered_terms, collapse = \" + \")\n}\n```\n\n## Variable importance\n\n```{r tbl-conservative-variations}\n#| tbl-cap: Number of conservative model variations with delta cAIC < 4 and < 2.\n\ntable <- con_var %>%\n  datatable(rownames = FALSE, filter = 'top', options = list(scrollX = TRUE, pageLength = 10), colnames = c(\"Species\", \"sum Œî cAIC < 4\" , \"sum Œî cAIC < 2\" , \"max ùìå·µ¢ Œî cAIC < 4\", \"max ùìå·µ¢ Œî cAIC < 2\"))\ntable\n```\n\n```{r fig-con-weights-d2, fig.height = 5, fig.width = 10, fig.cap=\"Parameter weights of conservative models with delta cAIC < 4 (D4) and < 2 (D2).\", internal=TRUE}\nweights <- weights_raw %>%\n  filter(MODEL == \"con\") %>%\n  mutate(SPECIES = case_when(\n             model_id %like% \"FS\" ~ \"Fagus\",\n             model_id %like% \"LD\" ~ \"Larix\",\n             model_id %like% \"PA\" ~ \"Picea\",\n             model_id %like% \"TC\" ~ \"Tilia\",\n             TRUE ~ model_id),\n         # Arrange by `category` first, then `term`\n         PARAMETER = factor(PARAMETER, levels = unique(PARAMETER[order(category, PARAMETER)]))) %>%\n  select(-model_id)\n\nggplot(weights, aes(x = SPECIES, y = PARAMETER, fill = WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.8, limit = c(0, 1), na.value = NA) +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"Species\") +\n  ylab(\"Parameter\") +\n  facet_wrap(~DELTA, scales = \"free_x\", ncol = 2) +\n  theme_report() +\n  theme(axis.text.x = element_text(hjust = 0.5))\n```\n\n```{r fig-importance, fig.width=7, fig.height=6, fig.cap=\"Relative variable importance (VI) in high-performing models of leaf unfolding. Shown are the VI of model variations with ŒîcAIC < 2 (cAIC = conditional Akaike Information Criterion) relative to the model with the lowest cAIC that contain GDD and ‚â§ 10 main effects and interactions. A VI of 1 signals high importance relative to other variables, while lower values suggest that a variable appeared in fewer models or models with lower Akaike weights. Variables with the prefix ‚Äúpoly‚Äù were modelled with a non-linear relationship to DOY (Methods). The colon (:) indicates an interaction between two variables. Blanks represent variables that were not present in any well-performing models.\"}\n\nweights <- list.files(path = paste0(path_output_data),\n                     pattern = \"^weights.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>%\n  filter(MODEL == \"con\",\n         DELTA == \"D2\") %>%\nmutate(\n  SPECIES_SHORT = str_extract(model_id, \"(?<=con_)[A-Z]{2}\"),\n  SPECIES = recode(SPECIES_SHORT, !!!rename_species_en),\n  order_num = case_when(PARAMETER_ABBR %like% \"Elevation\" ~ 0, # define parameter order within group\n                        PARAMETER_ABBR %like% \"Relief\" ~ 1,\n                        PARAMETER_ABBR %like% \"Slope inclination)\" ~ 2,\n                        PARAMETER_ABBR %like% \"Slope inc\" ~ 3,\n                        PARAMETER_ABBR %like% \"Slope aspect)\" ~ 3,\n                        PARAMETER_ABBR %like% \"CWB\" ~ 15,\n                        PARAMETER_ABBR %like% \"poly(AWC)\" ~ 15,\n                        PARAMETER_ABBR == \"poly(AWC)\" ~ 15,\n                        PARAMETER_ABBR %like% \"Social\" ~ 6,\n                        PARAMETER_ABBR %like% \"Stand\" ~ 7,\n                        PARAMETER_ABBR %like% \"Tree\" ~ 8,\n                        PARAMETER_ABBR == \"CDD\" ~ 9,\n                        PARAMETER_ABBR %like% \"CDD:poly\\\\(GDD\\\\)\" ~ 10,\n                        PARAMETER_ABBR %like% \"poly\\\\(GDD\\\\)\" ~ 11,\n                        PARAMETER_ABBR %like% \"CDD:GDD$\" ~ 12,\n                        PARAMETER_ABBR == \"GDD\" ~ 13,\n                        TRUE ~ 0),\n  category = case_when(PARAMETER_ABBR %like% \"CWB\" ~ \"Climate / Soil\",\n                              PARAMETER_ABBR %like% \"AWC\" ~ \"Climate / Soil\",\n                              category %like% \"Temperature\" ~ \"Climate / Soil\",\n                              TRUE ~ category),\n  PARAMETER = fct_reorder(PARAMETER_ABBR, order_num), # apply parameter order within group\n  category = fct_relevel(category, \"Stand structure\", \"Climate / Soil\", \"Topography\", \"Other\"), # order parameter groups\n  WEIGHT = round(WEIGHT, 2)\n  #PARAMETER = str_remove_all(PARAMETER_ABBR, \"[\\\\(\\\\)]\") %>% str_replace_all(\" \", \"_\")\n  )\n  \nggplot(weights, aes(x = SPECIES, y = PARAMETER, fill = WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.5, limit = c(0, 1), na.value = NA, name = \"VI\") +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"\") +\n  ylab(\"\") +\n  #scale_y_discrete(position = \"right\") +\n  scale_x_discrete(position = \"top\") +\n  facet_nested(rows = vars(category), scales = \"free_y\", space = \"free_y\", switch = \"y\") +\n  theme_report(legend.position=\"right\") +\n  theme(\n    legend.title = element_text(size = 12, face = \"bold\", hjust=0.1),\n    axis.text.x = element_text(hjust = 0.5),\n    strip.background = element_blank(),\n    strip.text = element_text(face = \"bold\", size = 10, hjust = 0.5),\n    panel.spacing.y = unit(1.5, \"lines\"),\n    axis.line.y = element_line(colour = \"grey\", linewidth = 1.2),\n    panel.grid = element_blank()\n    #panel.border = element_rect(color = \"grey\", fill = NA, linewidth = 0.5)\n    )\n```\n\n## Model selection\n\n```{r tbl-all-models, internal = TRUE}\n#| tbl-cap: Delta cAIC per type of all conservative candidate models across species.\n\nmodel_selection_all <- selection_parameters %>%\n  group_by(SPECIES_SHORT, family) %>%\n  ungroup() %>%\n  select(type, model_name, d.cAIC_group, SPECIES_SHORT) %>% \n  pivot_wider(names_from = SPECIES_SHORT, values_from = d.cAIC_group) %>%\n  filter(model_name %like% \"con\", # select conservative models\n         !model_name %like% \"temp_test\", # remove temperature test models\n         !model_name %like% \"global\" # remove global models\n         )\n\ntable <- model_selection_all %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\n\ntable\n```\n\n```{r set-filter-and-order}\nmodel_filter <- selection_parameters %>%\n  filter(model_name %like% \"con\", # select conservative \n         model_name %like% \"best_con_1\" | model_name %like% \"parsimonious_con_d2\" | model_name == \"ref_imp_con_int\" | model_name %like% \"ref_true_con_int\") %>%\n  pull(model_name)\n\nmodel_order <- c(\"best model\", \"parsimonious 1\", \"parsimonious 2\", \"parsimonious 3\", \"refined reference\", \"traditional reference\")\n```\n\n```{r tbl-select-best-per-group, internal=TRUE}\n#| tbl-cap: Conservative model types with the lowest cAIC across species.\n\ntable <- selection_parameters %>%\n  select(model_name, type, cAIC, SPECIES_SHORT) %>% \n  pivot_wider(names_from = SPECIES_SHORT, values_from = cAIC) %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\n\ntable\n```\n\n```{r tbl-delta-caic}\n#| tbl-cap: Delta cAIC of best conservative models per type across species.\n\ndelta_caic <- selection_parameters %>%\n  select(model_name, type, cAIC, logLik, RMSE, terms_count, SPECIES_SHORT) %>%\n  filter(model_name %in% model_filter) %>%\n  group_by(SPECIES_SHORT) %>%\n  mutate(d.cAIC = cAIC - min(cAIC, na.rm = TRUE),\n         RMSE_PERC = round(100 * RMSE / max(RMSE), 0)) %>%  # recalculate the delta values here to be sure they are correct\n  mutate(type = factor(type, levels = model_order)) %>%\n  arrange(SPECIES_SHORT, type)\n\nsaveRDS(delta_caic %>% ungroup(), paste0(path_output_data, \"/delta_caic.rds\"))\n\ntable <- delta_caic %>%\n  mutate_if(is.numeric, round, 2) %>%\n  select(SPECIES_SHORT, type, cAIC, d.cAIC, logLik, RMSE, RMSE_PERC, terms_count) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Model type\" , \"cAIC\", \"ŒîcAIC\" , \"log (ùìõ)\", \"RMSE\", \"% RMSE\", \"K\"))\ntable\n```\n\n```{r tbl-delta-RMSE, internal=TRUE}\n#| tbl-cap: Delta RMSE of best conservative models per type across species.\n\ndelta_rmse <- selection_parameters %>%\n  select(model_name, type, RMSE, SPECIES_SHORT) %>% \n  pivot_wider(names_from = SPECIES_SHORT, values_from = RMSE) %>%\n  filter(model_name %in% model_filter) %>% \n  mutate(across(where(is.numeric), ~ . - min(., na.rm = TRUE)),\n         type = factor(type, levels = model_order)) %>%\n  arrange(type) %>%\n  select(-model_name)\n\nsaveRDS(delta_rmse, paste0(path_output_data,\"/delta_rmse.rds\"))\n\ntable <- delta_rmse %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n```{r tbl-calls}\n#| tbl-cap: Model formula of best conservative models per type across species.\n\nbest_calls <- selection_parameters %>%\n  filter(model_name %in% model_filter) %>%\n  select(model_name, type, fixed_effects, SPECIES_SHORT) %>%\n  pivot_wider(names_from = SPECIES_SHORT, values_from = fixed_effects) %>%\n  mutate(type = factor(type, levels = model_order)) %>% \n  arrange(type) %>%\n  rename(Beech = FS,\n         Larch = LD,\n         Spruce = PA,\n         Lime = TC) %>%\n  select(-model_name) %>%\n  mutate(across(2:5, label_stats_fun),\n         across(2:5, ~map_chr(.x, rearrange_terms)))\n\nsaveRDS(best_calls, paste0(path_output_data, \"/calls_selected.rds\"))\n\ntable <- best_calls %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n```{r fig-selection-parameters-con, fig.height=6, fig.cap=\"Comparison of cAIC and RMSE across best conservative models per type. cAIC for Tilia cordata was scaled by 1.63 the improve readability.\", internal=TRUE}\nggplot(selection_parameters %>%\n         filter(model_name %in% model_filter) %>% \n         mutate(cAIC = case_when(SPECIES_SHORT == \"TC\" ~ cAIC * 1.63,\n                                 TRUE ~ cAIC)) %>%\n         pivot_longer(cols = c(cAIC, RMSE), names_to = \"selection_parameter\", values_to = \"value\") %>%\n         mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species),\n         type = factor(type, levels = c(model_order, setdiff(unique(type), model_order)))),\n       aes(x = type, y = value, colour=SPECIES)) +\n  #geom_rect(data=selection_parameters[1,], aes(xmin = 1-0.5, xmax = 2+0.5, ymin = -Inf, ymax = Inf), size=2, fill = \"#9CB51D\", alpha = 0.1, inherit.aes = FALSE) +\n  geom_point(alpha=0.5, size = 2) +\n  #geom_line(aes(group=SPECIES), alpha=0.5) +\n  ylab(\"Selection parameter\") +\n  xlab(\"Model name\") +\n  species_color_scale() +\n  facet_wrap(~selection_parameter, scales = \"free_y\") +\n  theme_report(angle=90, legend.position = \"top\")\n```\n\n## Model prediction accuracy\n\n```{r fig-fixed-vs-observed, fig.width=5, fig.height = 5, fig.cap =\"Model prediction accuracy using refined temperature-only models (black) and best models (green) to predict leaf unfolding across populations. Across-population predictions are based solely on fixed effects, excluding random effects and thus representing a generalized prediction. The dashed lines indicate perfect prediction of leaf unfolding, and deviations from it reflect prediction error.\"}\nggplot(data_unscaled %>%\n         left_join(augment %>%\n                     select(METEO_ID, year, .fixed, model_name, SPECIES_SHORT), by=c(\"METEO_ID\", \"year\", \"SPECIES_SHORT\")) %>%\n         filter(str_detect(model_name, \"best_con_1|ref_imp_con_int$\") & !str_detect(model_name, \"slo\")) %>%\n         mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en))) +\n  geom_point(aes(y=.fixed, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.4)+\n  geom_abline(slope = 1, intercept = 0, color = \"black\", linetype = \"dashed\", size = 0.5) +\n  #geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  geom_smooth(aes(y=.fixed, x= doy, group=model_name, colour=model_name), method=\"lm\", se=FALSE)+\n  facet_wrap(~SPECIES, ncol = 2, scales = \"fixed\") +\n  ylab(\"Predicted day of year\") +\n  xlab(\"Observed day of year\") +\n  scale_colour_manual(\n    values = c(\"best_con_1\" = \"#43CD80\", \"ref_imp_con_int\" = \"#666666\"),\n    labels = c(\"best_con_1\" = \"Best model\", \n               \"ref_imp_con_int\" = \"Refined model\"))+\n  theme_report(legend.position=\"top\", angle=90) +\n  theme(strip.background = element_rect(fill = NA, colour = NA, size = 1),\n        strip.text = element_markdown(hjust = 0.5, face = \"bold\"),\n        panel.border = element_rect(color = \"#CCCCCC\", fill = NA, linewidth=0.005))\n```\n\n```{r fig-predicted-vs-observed-scatter-all, fig.width=8, fig.height = 10, fig.cap =\"Fitted ~ observed and Fixed ~ observed day of year for each model across SPN sites.\", internal = TRUE}\nggplot(data_unscaled %>%\n         left_join(augment %>%\n                     select(METEO_ID, year, .fitted, .fixed, model_name, SPECIES_SHORT), by=c(\"METEO_ID\", \"year\", \"SPECIES_SHORT\")) %>%\n         filter(str_detect(model_name, \"best_con_1|ref_imp_con_int$\") & !str_detect(model_name, \"slo\")) %>%\n         pivot_longer(cols=c(.fitted, .fixed), names_to=\"PARAMETER\", values_to = \"VALUE\") %>%\n         mutate(PARAMETER = case_when(PARAMETER == \".fixed\" ~ \"across population\",\n                           PARAMETER == \".fitted\" ~ \"within population\"))) +\n  geom_point(aes(y=VALUE, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.2)+\n  geom_abline(slope = 1, intercept = 0, color = \"black\", linetype = \"dashed\", size = 0.5) +\n  #geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"lm\", se=FALSE)+\n  facet_wrap(~ interaction(PARAMETER, SPECIES_SHORT, sep = \" \"), ncol = 2, scales = \"free\") +\n  ylab(\"Predicted day of year\") +\n  xlab(\"Observed day of year\") +\n  scale_colour_manual(\n    values = c(\"best_con_1\" = \"#43CD80\", \"ref_imp_con_int\" = \"#666666\"),\n    labels = c(\"best_con_1\" = \"Best model\", \n               \"ref_imp_con_int\" = \"Refined model\"))+\n  theme_report(legend.position=\"top\", angle=90)\n```\n\n```{r fig-predicted-vs-observed-all-site, fig.height=15, fig.cap =\"Observed vs. fitted day of year for each final slope, best model and traditional and refined reference model for each species and SPN site.\", internal = TRUE}\nggplot()+\n  geom_line(data=data_unscaled, aes(x= year, y=doy, group=SAMPLE_CODE), colour=\"#BFBFBF\", size=1)+\n  geom_point(data=data_unscaled, aes(x= year, y=doy, group=SAMPLE_CODE), colour=\"#A1A1A1\", size=1.2)+\n  geom_line(data=augment %>% filter(model_name %in% model_filter), aes(x=year, y=.fitted, group=GROUP, colour=model_name), size = 0.5, alpha=0.5)+\n  geom_point(data=augment %>% filter(model_name %in% model_filter), aes(x=year, y=.fitted, group=GROUP, colour=model_name), size = 0.5, alpha= 0.5)+\n  facet_wrap(~METEO_ID, scale=\"free_y\", ncol=4)+\n  theme_report(legend.position = \"top\", angle=90)\n```\n\n```{r fig-predicted-vs-observed-selected, fig.height=7, fig.cap =\"Observed vs. fitted day of year for each final slope, best model and traditional and refined reference model for each species at the SPN site Thusis. Thusis was chosen because the site has a long and reliable time series of all four species.\", internal = TRUE}\n# alternative sites are ALD and DIH\n\nggplot(data=data_unscaled %>% filter(METEO_ID ==\"TUS\") %>% mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species)))+\n  geom_line(aes(x= year, y=doy, group=SPECIES_SHORT), colour=\"#BFBFBF\", size=1.5)+\n  geom_point(aes(x= year, y=doy, group=SPECIES_SHORT), colour=\"#A1A1A1\", size=1.5)+\n  geom_line(data=augment %>% filter(METEO_ID == \"TUS\", model_name %in% model_filter) %>% mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species)), aes(x=year, y=.fitted, group=model_name, colour=model_name), size = 1, alpha=0.5)+\n  geom_point(data=augment %>% filter(METEO_ID == \"TUS\", model_name %in% model_filter) %>% mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species)), aes(x=year, y=.fitted, group=model_name, colour=model_name), size = 1, alpha= 0.5)+\n  facet_wrap(~SPECIES, scale=\"free\", ncol=2)+\n  theme_report(legend.position = \"top\", angle=90)\n```\n\n## Coefficients\n\n```{r format-heatmap-input, internal = TRUE}\nheat_input <- coeff_table %>%\n  select(SPECIES, label, term, estimate, model_name, p.value) %>%\n  filter(term !=\"(Intercept)\",\n         !term %like% \"sd_\",\n         !term %like% \"cor\") %>%\n  mutate(p.value = round(p.value, 2))\n```\n\n```{r heat-plot-fun, internal = TRUE}\nheat_fun <- function(data, filter_string){\n  data_filtered <- data %>% filter(str_detect(model_name, filter_string))\n  \nggplot(data_filtered, aes(x = model_name, y = label, fill = estimate > 0)) +\n  geom_tile() +\n  scale_fill_manual(values = c(\"TRUE\" = \"#FFA07A\", \"FALSE\" = \"#BFEFFF\"), \n                    labels = c(\"FALSE\" = \"delaying\", \"TRUE\" = \"advancing\"), \n                    name = \"Effect\", \n                    na.value = NA) + # use this if coefficient size is not interpretable\n  # scale_fill_gradient2(low = \"#009ACD\", mid = \"grey\", high = \"#EE7600\", midpoint = 0, limit = c(min(data_filtered$estimate), max(data_filtered$estimate)), na.value = NA) + # use this if you want the gradient to reflect coefficient size\n  geom_tile(data = subset(data_filtered, p.value < 0.05), color = \"#6E6E6E\", linewidth = 0.5, fill = NA) +\n  facet_wrap(~SPECIES, scales = \"fixed\", ncol = 4) +\n  xlab(\"Model\") +\n  ylab(\"Parameter\") +\n  theme_report(angle = 90, legend.position = \"top\")\n\n}\n```\n\n```{r coeff-plot-fun}\ncoeff_fun <- function(data, filter_string, facet, rows) {\n  filtered_data <- data %>%\n    filter(\n      !term %like% \"sd\",\n      !term %like% \"cor\",\n      !term %like% \"Intercept\",\n      str_detect(model_name, filter_string)\n    ) %>%\n    arrange(term) %>%\n    mutate(\n      term = factor(term, levels = unique(term)),\n      label = factor(label, levels = unique(label)),\n      significance = factor(ifelse(p.value < 0.05, \"significant\", \"not significant\"), \n                            levels = c(\"significant\", \"not significant\"))\n    )\n  \n  ggplot(filtered_data, aes(x = estimate, y = label)) +\n    geom_vline(xintercept = 0, linetype = \"dashed\", size = 1, colour = \"grey\") +\n    geom_pointrange(aes(xmin = conf.low, xmax = conf.high, colour=significance), \n                    position=position_jitter(width=0.5), shape=21) +\n    scale_colour_manual(values = c(\"significant\" = \"#008B00\", \"not significant\" = \"grey\")) +\n    guides(colour = guide_legend(title = NULL)) +\n    facet_wrap(as.formula(paste0(\"~\", facet)), scales = \"free_x\", nrow = rows) +\n    ylab(\"\") +\n    xlab(\"Estimate\") +\n    theme(panel.border = element_rect(color = \"grey\", fill = NA, size = 0.4)) +\n    theme_report(legend.position = \"top\", angle = 90)\n}\n```\n\n\n### Reference models\n\nReference models with random slopes for warming and chilling never converged, even when warming was simplified to a linear term only. Models with a random slope for warming but not chilling converged only for Larix decidua and Tilia cordata, but not Picea abies and Fagus sylvatica. In general reference models for Fagus sylvatica had more conversion issues than reference models of other species.\n\n```{r fig-forrest-reference, fig.cap=\"Coefficient estimate and standard error per term for all zero models.\", fig.retina=2}\ncoeff_fun(coeff_table, \"ref_imp\", \"SPECIES\", 1)\n```\n\n```{r fig-heatmap-reference, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across zero models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"ref_imp_con_int_\") +\n    facet_wrap(~SPECIES, scales = \"free_x\", ncol=4)\n```\n\n```{r tbl-coefficients-refined}\n#| tbl-cap: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of refined models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals.\n\ntbl <- p_table_refined %>%\n    select(SPECIES, PARAMETER, everything(), -term, -model_name, -statistic, -category, -visual, -SPECIES_SHORT, -label, -GROUP) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Predictor\", \"conf.low\", \"estimate\" , \"conf.high\", \"SE\", \"p-value\")\n)\ntbl\n```\n\n<!-- start:internal -->\n### Global models\n\n```{r fig-forrest-global, fig.widht= 20, fig.height=6, fig.cap=\"Coefficient estimate and standard error per term for all global models.\", internal = TRUE}\ncoeff_fun(coeff_table, \"global\", \"SPECIES\", 1)\n```\n\n```{r fig-model-heatmap-global, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across global models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"global\")\n```\n<!-- end:internal -->\n\n### Best models\n\n```{r fig-forrest-best, fig.widht= 40, fig.height=6, fig.cap=\"Coefficient estimate and standard error per term for all best models.\", internal = TRUE}\ncoeff_fun(coeff_table, \"best\", \"SPECIES\", 1)\n```\n\n```{r fig-model-heatmap-best, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across best models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"best\")\n```\n\n```{r tbl-coefficients-best}\n#| tbl-cap: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of best models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals. The reference levels for relief position and social situation are ‚Äúupper slope‚Äù and ‚Äúforest‚Äù, respectively.\n\ntbl <- p_table %>%\n    select(SPECIES, PARAMETER, everything(), -term, -model_name, -statistic, -category, -visual, -SPECIES_SHORT, -label, -GROUP) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Predictor\" , \"conf.low\", \"estimate\" , \"conf.high\", \"SE\", \"p-value\")\n)\ntbl\n```\n\n### Parsimonious models\n\n```{r fig-forrest-parsimonious, fig.widht= 40, fig.height=6, fig.cap=\"Coefficient estimate and standard error per term for all parsimonious models.\", internal = TRUE}\ncoeff_fun(coeff_table, \"pars\", \"SPECIES\", 1)\n```\n\n```{r fig-model-heatmap-parsimonious, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across parsimonious models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"pars\")\n```\n\n```{r tbl-coefficients-pars}\n#| tbl-cap: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of most parsimonious models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals. The reference levels for relief position and social situation are ‚Äúupper slope‚Äù and ‚Äúforest‚Äù, respectively.\n\ntbl <- p_table_parsimonious %>%\n  mutate(model_name = case_when(model_name %like% \"parsimonious.*a\" ~ \"parsimonious 1\",\n                                model_name %like% \"parsimonious.*b\" ~ \"parsimonious 2\",\n                                model_name %like% \"parsimonious.*c\" ~ \"parsimonious 3\",\n                                TRUE ~ model_name)) %>%\n  arrange(SPECIES, model_name) %>% \n  select(SPECIES, model_name, PARAMETER, everything(), -term, -statistic, -category, -visual, -SPECIES_SHORT, -label, -GROUP) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Model\", \"Predictor\" , \"conf.low\", \"estimate\" , \"conf.high\", \"SE\", \"p-value\"))\ntbl\n```\n\n<!-- start:internal -->\n## Confounding effects\n```{r fig-coefficient-shifts, fig.height=8, fig.width=6, fig.cap=\"Shifts in p-value and coefficients of GDD and CDD terms across best, parsimonious, refined and traditional reference models.\"}\ncoefficient_shifts <- coeff_table %>%\n  filter(str_detect(term, \"GDD|CDD\"),\n         model_name %in% model_filter) %>%\n  select(label, model_name, SPECIES, p.value, estimate) %>%\n  arrange(SPECIES) %>%\n  group_by(SPECIES, label) %>%\n  filter(n() > 1) %>%\n  arrange(SPECIES, model_name) %>%\n  pivot_longer(c(p.value, estimate), names_to = \"PARAMETER\", values_to = \"VALUE\")\n\nggplot(coefficient_shifts, aes(x = label, y = VALUE, colour=SPECIES)) +\n  geom_jitter(alpha=0.5, size = 2, width=0.2) +\n  species_color_scale(\"short\") +\n  labs(x = \"Parameter\", y=\"\") +\n  facet_wrap(~PARAMETER, scales = \"free_y\", ncol = 1) +\n  theme_report(angle=90, legend.position = \"top\")\n```\n<!-- end:internal -->\n\n## Effects of variables\n\n```{r plot-all-effects-fun, internal = TRUE}\neffects_all_fun <- function(data, order, label) {\n  data <- data %>%\n    filter(!is.na(x)) %>% \n    mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en),\n           Label = factor(Label, levels = c(order, setdiff(unique(Label), order)))) %>%\n    group_by(Label) %>%\n    mutate(Letters = paste0(\"<b>\", letters[cur_group_id()], \"</b>\")) %>%\n    ungroup()\n\n  ggplot(data, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high)) +\n    geom_line(size = 1, aes(group = interaction(SPECIES, model_name), colour = SPECIES)) +\n    geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = SPECIES_SHORT, group = interaction(SPECIES, model_name)), \n                fill = \"grey\", alpha = 0.3, color = NA) +\n    facet_wrap(~Letters + Label, scales = \"free_x\") +\n    labs(x = \"\", y = \"Day of Year\") +\n    #coord_cartesian(ylim = c(60, 150))+ #specified as coord carthesian to avoid cutting confidence intervals outside the ylim\n    ylim(50, 160)+\n    species_color_scale(label) +\n    theme_report(legend.position = \"top\", hjust = 0.5) +\n    theme(\n      strip.background = element_rect(fill = NA, colour = NA, size = 1),\n      panel.spacing = unit(1, \"lines\"),\n      strip.text = element_markdown(hjust=0)\n    )\n}\n```\n\n```{r load-all-models}\nall_models <- list.files(path = paste0(path_output_data),\n                     pattern = \"^models.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  lapply(readRDS) %>% \n  bind_rows()\n```\n\n```{r fun-process-and-predict-all-models}\nprocess_and_predict_df <- function(model_df, family) {\n  predictions_df <- NULL\n  filtered_model_df <- model_df %>% filter(str_detect(model_name, family))\n    \n  random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n  assign(\"random_simple\", random_simple, envir = .GlobalEnv)\n    \n  autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n  assign(\"autoregression_simple\", autoregression_simple, envir = .GlobalEnv)\n  \n  for (i in seq_len(nrow(filtered_model_df))) {\n    model <- filtered_model_df$model[[i]] # filter model\n    fixed_effects <- formula(model) # get fixed effects\n    model[[\"call\"]][[\"fixed\"]] <- as.formula(fixed_effects) # paste fixed effect back into the model to replace \"fixed effects\"\n    terms <- filtered_model_df[[\"terms\"]][[i]] # get terms\n\n    for (term in terms) {\n      # make prediction\n      prediction <- tryCatch({\n        predict_response(model, terms = paste(term, \"[all]\", sep = \" \"))\n      }, error = function(e) {\n        NULL  # Return NULL on error\n      }) %>%\n        as.data.frame() %>% # transform prediction output to data frame\n        mutate(model_name = paste0(filtered_model_df$model_name[[i]]), # add model name\n               SPECIES_SHORT = paste0(filtered_model_df$SPECIES_SHORT[[i]])) # add species\n      \n      if (!is.null(prediction)) {\n        prediction$x <- as.numeric(as.character(prediction$x))\n        #prediction$Model <- species\n        prediction$Term <- term\n        \n        if (is.null(predictions_df)) {\n          predictions_df <- prediction\n        } else {\n          predictions_df <- bind_rows(predictions_df, prediction) %>% as.data.frame() %>% mutate(Label = label_fun_sim(Term, col = \"short\"))\n        }\n      }\n    }\n  }\n  \n  predictions_df\n}\n\nsaveRDS(process_and_predict_df, paste0(path_helpers, \"/process_and_predict_df.rds\"))\n```\n\n<!-- start:internal -->\n### Best models\n<!-- end:internal -->\n\n```{r extract-effects-best-con, include=FALSE}\n# categoric variables\nmodels_categoric <-  all_models %>% filter(model_name == \"best_con_1\", SPECIES_SHORT == \"LD\")\n\nrandom_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n  assign(\"random_simple\", random_simple, envir = .GlobalEnv)\n    \nautoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n  assign(\"autoregression_simple\", autoregression_simple, envir = .GlobalEnv)\n\neffects_relief <- predict_response(models_categoric[[3]][[1]], terms = \"RELIEF [all]\", sep = \" \") %>%\n  as.data.frame() %>%\n  mutate(Term = \"RELIEF\",\n         SPECIES_SHORT = \"LD\")\n\neffects_social <- predict_response(models_categoric[[3]][[1]], terms = \"SOCIAL_SITUATION [all]\", sep = \" \") %>%\n  as.data.frame() %>%\n  mutate(Term= \"SOCIAL_SITUATION\",\n         SPECIES_SHORT = \"LD\")\n\neffects_best_con_categoric <- bind_rows(effects_social, effects_relief) %>%\n  mutate(PARAMETER = label_fun_sim(as.character(Term)),\n         Label = label_fun_sim(as.character(Term), col = \"short\"),\n         SPECIES = recode(SPECIES_SHORT, !!!rename_species_en))\n\n# numeric variables\neffects_best_con_numeric <- process_and_predict_df(all_models, \"best_con_1\") %>%\n  mutate(Label = label_fun_sim(as.character(Term), col = \"short\"))\n```\n\n```{r effect-size-best-con}\n# standardize effect size and estimate potential effect on net ecosystem productivity in CO2\neffects_best_numeric <- effects_best_con_numeric %>% mutate(x = as.character(x))\neffects_best_categoric <- effects_best_con_categoric %>% mutate(x = as.character(x))\n\neffect_size_best <- bind_rows(effects_best_numeric, effects_best_categoric) %>%\n  group_by(SPECIES_SHORT, Term, Label) %>%\n  summarise(MAX_MEAN_EFFECT_SIZE = round(max(predicted) - min(predicted), 2),\n            MEAN_STD_ERROR = round(mean(std.error), 2),\n            MIN_TERM = x[which.min(predicted)],\n            MAX_TERM = x[which.max(predicted)],\n            CARBON_PREDICTION = MAX_MEAN_EFFECT_SIZE * 4) %>%\n  arrange(desc(CARBON_PREDICTION)) %>%\n  filter(!is.na(Label),# remove excess labels from categoric variables\n         MAX_MEAN_EFFECT_SIZE > 0) %>% \n  rename(PARAMETER = Term) %>% \n  mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en)) %>%\n  ungroup() %>% \n  select(Label, SPECIES, everything())\n\nsaveRDS(effect_size_best %>% ungroup(), paste0(path_output_data, \"/effect_size_best_con.rds\"))\n```\n\n```{r fig-effect-size, fig.height=5, fig.width=6, fig.cap=\"Estimated shift (d) between earliest and latest DOY across the observed range of each environmental variable, based on predictions adjusted to mean covariate values. For each species, colours are scaled so the darkest shade represents the strongest shift.\"}\nfacet_stats <- effect_size_best %>%\n  group_by(SPECIES) %>%\n  summarise(\n    min_val = min(MAX_MEAN_EFFECT_SIZE, na.rm = TRUE),\n    max_val = max(MAX_MEAN_EFFECT_SIZE, na.rm = TRUE),\n    mid_val = mean(MAX_MEAN_EFFECT_SIZE, na.rm = TRUE),\n    .groups = \"drop\")\n\neffect_scaled <- effect_size_best %>%\n  left_join(facet_stats, by = \"SPECIES\") %>%\n  mutate(scaled_effect = (MAX_MEAN_EFFECT_SIZE - min_val) / (max_val - min_val)) %>%\n  inner_join(label_table %>% select(term, param_order_c1, category), by = c(\"PARAMETER\" = \"term\")) %>% # partial join with order of parameters\n  mutate(category = case_when(category == \"Soil\" ~ \"Climate / Soil\",\n                              category == \"Drought\" ~ \"Climate / Soil\",\n                              category == \"Climate\" ~ \"Climate / Soil\",\n                              TRUE ~ category),\n         Label = case_when(Label %like% \"Social\" ~ \"Social position\",\n                          TRUE ~ Label),\n         order_num = case_when(PARAMETER %like% \"ELEVATION\" ~ 0, # define parameter order within group\n                        PARAMETER %like% \"RELIEF\" ~ 1,\n                        PARAMETER %like% \"INCLINATION\" ~ 2,\n                        PARAMETER %like% \"ASPECT\" ~ 3,\n                        PARAMETER %like% \"SOCIAL\" ~ 6,\n                        PARAMETER %like% \"STAND\" ~ 7,\n                        PARAMETER %like% \"HEIGHT\" ~ 8,\n                        PARAMETER %like% \"DROUGHT\" ~ 13,\n                        PARAMETER %like% \"AWC\" ~ 12,\n                        PARAMETER %like% \"CDD\" ~ 10,\n                        PARAMETER %like% \"GDD\" ~ 11,\n                        TRUE ~ 0),\n         PARAMETER = fct_reorder(Label, order_num),\n        category = fct_relevel(category, \"Stand structure\", \"Climate / Soil\", \"Topography\")) # order parameter groups\n\nggplot(effect_scaled, aes(x = SPECIES, y = PARAMETER, fill = scaled_effect)) +\n  geom_tile() +\n  scale_fill_gradient2(\n    low = \"#FFA54F\", mid = \"#FF7F24\", high = \"#CD661D\", midpoint = 0.5, limits = c(0, 1)) +\n  geom_text(aes(label = round(MAX_MEAN_EFFECT_SIZE, 2)), size = 4, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_x_discrete(position = \"top\") +\n  facet_nested(rows = vars(category), scales = \"free_y\", space = \"free_y\", switch = \"y\") +\n  theme_report(legend.position = \"none\") +\n  theme(\n    legend.title = element_text(size = 12, face = \"bold\", hjust = 0.1),\n    axis.text.x = element_text(hjust = 0.5, face = \"bold\"),\n    strip.background = element_blank(),\n    strip.text.y.left = element_text(face = \"bold\", size = 10, hjust = 0.5, colour = \"#757575\"),\n    panel.spacing.y = unit(1.1, \"lines\"),\n    axis.line.y = element_line(colour = \"grey\", linewidth = 1.2),\n    panel.grid = element_blank()\n  )\n```\n\n```{r effects-nature-fun}\ntheme_nature <- function() {\n  theme(\n    legend.position = \"none\",\n    axis.text.x = element_text(size = 10, vjust = 0.5, hjust = 0.5),\n    axis.text.y = element_blank(),\n    axis.ticks = element_blank(),\n    strip.background = element_rect(fill = NA, colour = NA, size = 1),\n    panel.spacing = unit(1, \"lines\"),\n    strip.text = element_markdown(hjust = 0),\n    plot.title = element_text(size = 10),\n    axis.title.x = element_text(size = 10.5),\n    plot.margin = margin(t = 10, b = 10, r = 3, l = 3),\n    panel.border = element_rect(color = \"#E8E8E8\", fill = NA, linewidth=1.5),\n    panel.grid.minor = element_blank()\n  )\n}\n\n# numeric plots\neffects_fun_num <- function(data, label, type = \"line\"){\n  data <- data %>%\n    mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en)) %>%\n      filter(!is.na(x))\n  \n  terms <- unique(data$Term)\n  \n  plots <- list()\n  \n  for (i in terms) {\n    plot_data <- data %>%\n      filter(Term == i)\n\n    p <- ggplot(plot_data, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high)) +\n      geom_line(size = 1, aes(group = interaction(SPECIES, model_name), colour = SPECIES)) +\n      geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = SPECIES_SHORT, group = interaction(SPECIES, model_name)), \n                  fill = \"grey\", alpha = 0.3, color = NA) +\n      labs(x = paste0(\" \", unique(plot_data$Label)), y = \"\") +\n      coord_cartesian(ylim = c(65, 150))+\n      #ylim(60, 160)+\n      #ggtitle(paste0(\" \", unique(plot_data$Letters), unique(plot_data$Label))) +\n      ggtitle(paste0(\" \")) +\n      species_color_scale(paste0(label)) +\n      theme_report() +\n      theme_nature()\n    \n     plots[[i]] <- p\n  }\n    return(plots)\n}\n\n# categorical plots\neffects_fun_cat <- function(data, label, type = \"line\"){\n  terms <- unique(data$Term)\n  \n  plots <- list()\n  \n  data <- data %>%\n    mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en))\n  \n  for (i in terms) {\n    order <- c(\"flat\", \"base\", \"mid\", \"upper\", \"free\", \"group\", \"forest\")\n    \n    plot_data <- data %>%\n      filter(Term == i) %>%\n      mutate(x = case_when(x %like% \"crest\" ~ \"upper\",\n                           x %like% \"base\" ~ \"base\",\n                           x %like% \"mid\" ~ \"mid\",\n                           x %like% \"stand\" ~ \"free\",\n                           TRUE ~ x), \n             x = factor(x, levels = c(order, setdiff(unique(x), order))))\n\n    p <- ggplot(plot_data, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high)) +\n      geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, colour= \"grey\") +\n      geom_point(aes(colour = SPECIES), size = 2.5) +\n      labs(x = paste0(\" \", unique(plot_data$PARAMETER)), y = \"\") +\n      coord_cartesian(ylim = c(65, 150))+\n      #ylim(60, 160)+\n      #ggtitle(paste0(\" \", unique(plot_data$PARAMETER))) +\n      ggtitle(paste0(\" \")) +\n      species_color_scale(paste0(label)) +\n      theme_report() +\n      theme_nature()\n\n     plots[[i]] <- p\n  }\n    return(plots)\n}\n```\n\n```{r generate-plots}\n# Generate numeric and categorical plots\nplots_num_all <- effects_fun_num(effects_best_con_numeric, \"english\")\nplots_cat_par <- effects_fun_cat(effects_best_con_categoric, \"english\")\n\n# Extract legend from the numeric plot\ng_bottom <- ggplotGrob(plots_num_all[[\"GDD_conservative\"]] + theme(legend.position = \"bottom\"))\nlegend_grob_bottom <- g_bottom$grobs[which(sapply(g_bottom$grobs, function(x) x$name) == \"guide-box\")][[1]]\nplot_legend_bottom <- ggdraw() + draw_grob(as_grob(legend_grob_bottom))\n\n# Extract legend from the numeric plot\ng_right <- ggplotGrob(plots_num_all[[\"GDD_conservative\"]] + theme(legend.position = \"right\"))\nlegend_grob_right <- g_right$grobs[which(sapply(g_right$grobs, function(x) x$name) == \"guide-box\")][[1]]\nplot_legend_right <- ggdraw() + draw_grob(as_grob(legend_grob_right))\n\n# Bind elements\nplots_list <- c(plots_num_all, plots_cat_par, list(Legend = plot_legend_right) # add legend as object if it should be treated as a plot\n                )\n\n# add axis labels to left side plots\nplots_list[names(plots_list) %in% c(\"TREE_HEIGHT\", \"SLOPE_ASPECT_HL\", \"DROUGHT\")] <-\n  map(plots_list[names(plots_list) %in% c(\"TREE_HEIGHT\", \"SLOPE_ASPECT_HL\", \"DROUGHT\")],\n      ~ .x + theme(axis.text.y = element_text(), axis.ticks.y = element_line()))\n\n# Order plots\ndesired_order <- c(\"TREE_HEIGHT\", \"STAND_HEIGHT\",\n                   \"SOCIAL_SITUATION\", \"AWC\", \"DROUGHT\", \"RELIEF\", \n                   \"SLOPE_ASPECT_HL\", \"SLOPE_INCLINATION_DEG\", \"TREE_ELEVATION\",#, \"Legend\" # add legend as object if it should be treated as a plot\n                   \"GDD_conservative\", \"CDD_conservative\", \"Legend\")  \n\nordered_plots <- plots_list[desired_order]\n\n#letters_list[length(letters_list)] <- \"\"  # Remove letter assigned to legend legend if legend is treated as a plot\n```\n\n```{r order-plots-thematic}\n# Define plot groupings\ngroup_titles <- c(\n  \"Stand structure\",\n  \"Climate / Soil\",\n  \"Topography\"\n#  \"Temperature\"\n)\n\n# Split ordered plots into thematic rows\nplot_rows <- list(\n  ordered_plots[c(\"TREE_HEIGHT\", \"STAND_HEIGHT\", \"SOCIAL_SITUATION\", \"Legend\")],\n  ordered_plots[c(\"DROUGHT\", \"AWC\", \"GDD_conservative\", \"CDD_conservative\")],\n  ordered_plots[c(\"SLOPE_ASPECT_HL\", \"SLOPE_INCLINATION_DEG\", \"RELIEF\", \"TREE_ELEVATION\")])\n\nflat_plots <- unlist(plot_rows, recursive = FALSE)\n# Determine where the \"Legend\" is\nlegend_pos <- which(names(flat_plots) == \"Legend\")\n\n# Create letters and insert \"\" at the right spot\npanel_letters <- letters[1:(length(flat_plots) - 1)]\npanel_letters <- append(panel_letters, \"\", after = legend_pos - 1)\n\n# Define max columns (based on longest row)\nmax_cols <- max(lengths(plot_rows))\n\nn_rows <- length(plot_rows)\nn_cols <- max_cols\n\nx_positions <- rep(seq(0.121, 0.833, length.out = n_cols), times = n_rows)\ny_positions <- rep((seq(1, 0.33, length.out = n_rows)), each = n_cols)\n\n# Function to pad a row to fixed width\npad_row <- function(plots, total_cols = max_cols) {\n  n_missing <- total_cols - length(plots)\n  if (n_missing > 0) {\n    plots <- c(plots, rep(list(NULL), n_missing))  # pad with empty slots\n  }\n  return(plots)\n}\n\nplot_object <- tibble(\n  order = flat_plots[names(flat_plots)],\n  parameter = names(order),\n  letters = panel_letters)\n```\n\n```{r fig-effects-best-all-thematic, fig.width=11, fig.height=7, fig.cap=\"Species-specific environmental drivers beyond temperature shape the timing of leaf unfolding. Panels show the estimated effect of predictors present in species-specific best models, adjusted for the influence of other included covariates at their mean values. Shaded areas and error bars represent 95% confidence intervals.\"}\n# Adjusted label drawer with rotation\nrotated_label <- function(label_text) {\n  ggdraw() + \n    draw_label(\n      label_text,\n      angle = 90,               # rotate\n      hjust = 0.5,              # center vertically\n      vjust = 0.5,\n      size = 13\n      ) + #fontface = \"bold\"\n    theme(plot.margin = margin(t = 0, r = -30, b = 0, l = 0))  # pulls label closer\n}\n\nrotated_label <- function(label_text) {\n  ggdraw() + \n    draw_line(                     # vertical line\n      x = c(-0.3, -0.3),\n      y = c(0.05, 0.95),\n      size = 1.2,\n      color = \"grey\"\n    ) +\n    draw_label(\n      label_text,\n      angle = 90,\n      hjust = 0.5,\n      vjust = 0.5,\n      size = 13\n    ) +\n    theme(plot.margin = margin(t = 0, r = -20, b = 0, l = 0))\n}\n\n# adjust for column with narrow plots due to axis labels\naligned_plot_rows <- map(plot_rows, ~ align_plots(plotlist = pad_row(.x), align = \"hv\", axis = \"tblr\"))\n\nannotated_rows <- map2(aligned_plot_rows, group_titles,\n  ~ plot_grid(\n      rotated_label(.y),\n      plot_grid(plotlist = .x, ncol = max_cols),\n      ncol = 2,\n      rel_widths = c(0.02, 0.99),\n      align = \"v\",\n      axis = \"tb\"))\n\n# Combine into final layout\nfinal_plot <- plot_grid(\n  plotlist = annotated_rows,\n  ncol = 1,\n  rel_heights = rep(1, length(annotated_rows)))  # uniform row heights\n\nfinal_plot_labeled <- ggdraw() +\n  draw_plot(final_plot, x = 0.05, y = 0, width = 0.97, height = 1) +  # shift right to make room\n  draw_label(\n    \"Day of year\",\n    x = 0.01, y = 0.5,\n    angle = 90,\n    fontface = \"bold\",\n    size = 16)\n\nfinal_plot_labeled_with_letters <- ggdraw() +\n  draw_plot(final_plot_labeled) +\n  draw_plot_label(\n    label = panel_letters,  # <- reverse here\n    x = x_positions,\n    y = y_positions,\n    size = 14,\n    fontface = \"bold\") +\n  theme(plot.margin = margin(r = 30))\n\nfinal_plot_labeled_with_letters\n```\n\n<!-- start:internal -->\n### Parsimonious models\n\n```{r process-pars-con}\neffects_pars2d_con <- process_and_predict_df(all_models, \"parsimonious_con_d2\") %>%\n  mutate(Label = label_fun_sim(Term))\n```\n\n```{r fig-effects-pars-con, fig.width=6, fig.height=8, fig.cap=\"Mean effects of parameters on day of year for each most parsimonious conservative model and species.\"}\norder <- c(\"Tree height (m)\", \"Stand height (m)\", \"Available water capacity (cm¬≥)\", \"Climatic water balance (mm)\", \"Growing degree days (¬∞C days)\", \"Chilling degree days (¬∞C days)\", \"Elevation (m)\")\n\norder_de <- c(\"W√§rmesumme (¬∞C Tage)\", \"K√§ltesumme (¬∞C Tage)\", \"Baumh√∂he (m)\", \"Bestandesh√∂he (m)\", \"Wasserspeicherkapazit√§t (cm¬≥)\", \"Klimatische Wasserbilanz (mm)\", \"Seeh√∂he (m)\")\n\neffects_all_fun(effects_pars2d_con, order, \"english\")\n```\n<!-- end:internal -->\n\n### Effects of interactions\n\n```{r interaction-effect-fun}\ninteraction_effect_fun <- function(model_string, species_string, term_string, lab_string, legend_string = c(\"low\", \"medium\", \"high\"), color_string = c(\"#FF7F00\", \"#698B22\", \"#1874CD\")){\n\nfiltered_models <- all_models %>% filter(str_detect(model_name, model_string), str_detect(SPECIES_SHORT, species_string))\nprediction <- predict_response(filtered_models$model[[1]], term = term_string)\n  \nggplot(prediction, aes(x = x, y = predicted)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group), \n                fill = \"grey\", alpha = 0.3, color = NA)+\n  geom_line(size = 1, aes(group = factor(group), colour = factor(group))) +\n  labs(x = lab_string, y = \"Day of year\", colour = \"Group\") +\n  scale_color_manual(values = color_string, labels = legend_string) +\n  guides(colour = guide_legend(reverse = TRUE)) + # Reverse the legend order\n  theme_report(legend.position = \"top\", hjust = 0.5) +\n  theme_nature()\n}\n```\n\n```{r fig-effects-warming-chilling-tc1, fig.width = 4, fig.height = 4, fig.cap=\"Effect of the interaction between GDD and CDD at low, medium and high CDD in the best model of lime. Predictions are adjusted to mean covariate values, with 95% confidence intervals (grey).\"}\ninteraction_effect_fun(\"best_con_1\", \"TC\", c(\"GDD_conservative [all]\", \"CDD_conservative\"), \"Growing degree days (¬∞C day)\", c(\"low CDD\", \"medium CDD\", \"high CDD\")) +\n  theme_nature()+\n  theme(legend.position = \"top\")\n```\n\n```{r fig-effects-awc-cwb, fig.width = 4, fig.height = 4, fig.cap=\"Effect of the interaction between AWC and CWB at low, medium and high AWC in the best model of spruce. Predictions are adjusted to mean covariate values. Shaded areas represent 95% confidence intervals.\"}\ninteraction_effect_fun(\"best_con_1\", \"PA\", c(\"DROUGHT [all]\", \"AWC\"), \"Climatic water balance (mm)\", c(\"low AWC\", \"medium AWC\", \"high AWC\")) + \n  theme_nature()+\n  theme(legend.position = \"top\")\n```\n\n```{r fig-effects-warming-chilling, fig.width = 4, fig.height = 3, eval=FALSE, internal = TRUE}\n# manual plot for tricky interactions\nfiltered_models <- all_models %>% filter(str_detect(model_name, \"best_con_1\"), str_detect(SPECIES_SHORT, \"TC\"))\nprediction <- ggpredict(filtered_models$model[[1]], term = c(\"GDD_conservative [all]\", \"CDD_conservative [250, 350, 550]\"))\n\nfiltered_prediction <- prediction %>%\n  as.data.frame() %>% \n    mutate(site_type = case_when(\n    group == 250 ~ \"low CDD\",    # Warm site group\n    group == 350 ~ \"medium CDD\",  # Medium site group\n    group == 550 ~ \"high CDD\"     # Cold site group\n  )) %>%\n  filter(\n    # remove CDD-GDD combinations that do not occur in reality\n    (site_type == \"low CDD\" & x >= 200 & x <= 600) |\n    (site_type == \"medium CDD\" & x >= 0 & x <= 300) |\n    (site_type == \"high CDD\" & x >= 0 & x <= 220)\n  )\n\nggplot(filtered_prediction, aes(x = x, y = predicted, colour = site_type)) +\n  geom_line(size = 1, aes(group = interaction(site_type, group))) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = site_type, group = site_type), \n              alpha = 0.3, colour = NA) +\n  scale_color_manual(values = c(\"high CDD\" = \"#1874CD\", \"low CDD\" = \"#FF7F00\", \"medium CDD\" = \"#698B22\"))+\n  scale_fill_manual(values = c(\"high CDD\" = \"grey\", \"low CDD\" = \"grey\", \"medium CDD\" = \"grey\")) + \n  labs(x = \"Growing Degree Days (¬∞C day)\", y = \"Day of Year\", colour = \"Site Type\", fill = \"Site Type\") +\n  theme_report(legend.position = \"top\", hjust = 0.5)\n```\n\n```{r save-output}\nsaveRDS(model_filter, paste0(path_output_data, \"/model_filter.rds\"))\nsaveRDS(plot_object, paste0(path_output_data, \"/facet_reference.rds\"))\n```\n","srcMarkdownNoYaml":"\n\n# Species comparison\n\n```{r source, include=FALSE}\nlocation <- paste0(getwd())\nsource(paste0(\"../00_helpers/setup.R\")) #common libraries and custom functions\nsource(paste0(\"../00_helpers/species_and_phases.R\"))\n\nlib_results <- c(\n  \"ggeffects\",\n  \"nlme\",\n  \"cowplot\",\n  \"ggtext\",\n  \"ggh4x\" # nested facets\n  )\npackage_fun(lib_results, \"results2\")\n\ntype <- \"con\"\n```\n\n```{r load-table, include=FALSE}\ncoeff_table <- list.files(path = paste0(path_output_data),\n                     pattern = \"^table.*\\\\.csv$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(read.csv) %>% \n  bind_rows() %>%\n  unite(\"GROUP\", model_name, SPECIES, sep=\"_\", remove=FALSE)\n```\n\n```{r format-p-table}\np_table <- coeff_table %>% \n  mutate(SPECIES_SHORT = SPECIES,\n         SPECIES = recode(SPECIES_SHORT, !!!rename_species_en),\n         label = label_fun_sim(term, \"short\"),\n         PARAMETER = label) %>% \n  arrange(SPECIES,\n          str_detect(term, \"sd_\"),\n          str_detect(term, \"Intercept\"),\n          str_detect(term, \"TREE_HEIGHT\"),\n          str_detect(term, \"DROUGHT\"),\n          str_detect(term, \"ELEVATION\"),\n          str_detect(term, \":\"),\n          str_detect(term, \"CDD\"),\n          str_detect(term, \"GDD\"),\n          term) %>% \n  mutate(across(where(is.numeric), ~ round(.x, 3))) %>%\n  mutate(p.value = as.character(p.value),\n         p.value = case_when(p.value == 0.000 ~ \"‚â§ 0.001\",\n                             TRUE ~ p.value))\n\nsaveRDS(p_table, paste0(path_output_data, \"/p_table.rds\"))\n\np_table_test <- p_table %>%\n    filter(str_detect(model_name, paste0(\"temp_test_con_int\")))\n\np_table_refined <- p_table %>%\n    filter(str_detect(model_name, paste0(\"ref_imp_con_int$\")))\n\np_table_parsimonious <- p_table %>% \n    filter(str_detect(model_name, paste0(\"parsimonious_con_d2\")))\n\np_table <- p_table %>%\n    filter(str_detect(model_name, paste0(\"best_con_1\")))\n```\n\n```{r load-augment}\naugment <- list.files(path = paste0(path_output_data),\n                     pattern = \"^augment.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>% \n  unite(\"GROUP\", model_name, SPECIES_SHORT, sep=\"_\", remove=FALSE) %>%\n  filter(str_detect(model_name, paste0(type)))\n```\n\n```{r load-data}\ndata_unscaled <- list.files(path = paste0(path_own_data),\n                     pattern = \"^data_unscaled.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows()\n```\n\n```{r load-selection-parameters}\nselection_parameters <- list.files(path = paste0(path_output_data),\n                     pattern = \"^selection_parameters.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>% \n  filter(model_name %like% \"con\") %>%\n  mutate(type = case_when(model_name %like% \"parsimonious.*a\" ~ \"parsimonious 1\",\n                          model_name %like% \"parsimonious.*b\" ~ \"parsimonious 2\",\n                          model_name %like% \"parsimonious.*c\" ~ \"parsimonious 3\",\n                          TRUE ~ type))\n```\n\n```{r load-con-variations-summary}\ncon_var <- list.files(path = paste0(path_output_data),\n                      pattern = \"^con_variations_.*\\\\.rds$\",\n                      full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[3:3], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows()\n```\n\n```{r load-weights}\nweights_raw <- list.files(path = paste0(path_output_data),\n                     pattern = \"^weights_.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>%\n  filter(str_detect(MODEL, paste0(type)))\n```\n\n```{r fun-format-equations}\nlabel_stats_fun <- function(term) {\n  # strip doy\n  term <- str_replace_all(term, \"doy ~\", \"\")\n  # strip 1\n  term <- str_replace_all(term, \"\\\\+\\\\s*1\", \"\")\n  term <- str_replace_all(term, \"1\\\\s*\\\\+\", \"\")\n  \n  # Correctly format interactions (replace * and separate interaction terms)\n  term <- str_replace_all(term, \"\\\\:\", \" * \")  \n  \n  # Remove ', degree = 2' with flexible spaces\n  term <- str_replace_all(term, \",\\\\s*degree\\\\s*=\\\\s*2\", \"\")\n\n  # Remove trailing '1' or '2' after the closing parenthesis\n  term <- str_replace_all(term, \"\\\\)\\\\s*[12]\", \")\")\n  \n  # Replace specific variables with formatted labels\n  term <- str_replace_all(term, \"CLIM_BALANCE\", \"CWB\")\n  term <- str_replace_all(term, \"CDD_conservative\", \"CDD\")\n  term <- str_replace_all(term, \"CDD_mainstream\", \"CDD\")\n  term <- str_replace_all(term, \"GDD_conservative\", \"GDD\")\n  term <- str_replace_all(term, \"GDD_mainstream\", \"GDD\")\n  term <- str_replace_all(term, \"TREE_ELEVATION\", \"Elevation\")\n  term <- str_replace_all(term, \"TREE_HEIGHT\", \"Tree height\")\n  term <- str_replace_all(term, \"STAND_HEIGHT\", \"Stand height\")\n  term <- str_replace_all(term, \"EDGE_DISTANCE_IMPUTED\", \"Distance forest edge imputed\")\n  term <- str_replace_all(term, \"EDGE_DIST\", \"Distance forest edge\")\n  term <- str_replace_all(term, \"SLOPE_ASPECT_HL\", \"Slope aspect\")\n  term <- str_replace_all(term, \"SLOPE_INCLINATION_DEG\", \"Slope inclination\")\n  term <- str_replace_all(term, \"DROUGHT\", \"CWB\")\n  term <- str_replace_all(term, \"AWC\", \"AWC\")\n  term <- str_replace_all(term, \"RELIEF\", \"Relief\")\n  term <- str_replace_all(term, \"SOCIAL_SITUATION\", \"Social position\")\n  term <- str_replace_all(term, \"METEO_ID\", \"Site\")\n  term <- str_squish(term)\n  term\n}\n\nrearrange_terms <- function(expression) {\n  terms <- unlist(strsplit(expression, \" \\\\+ \")) |> trimws()\n\n  interaction_terms <- terms[str_detect(terms, \"\\\\s*\\\\*\\\\s*\")]\n\n  temp_interaction_terms <- keep(interaction_terms, ~ str_detect(.x, \"GDD|CDD\"))\n  env_interaction_terms <- setdiff(interaction_terms, temp_interaction_terms)\n\n  other_terms <- setdiff(terms, interaction_terms)\n  all_interaction_terms <- c(temp_interaction_terms, env_interaction_terms)\n  other_terms <- keep(other_terms, ~ !any(str_detect(all_interaction_terms, fixed(.x))))\n\n  gdd_terms <- keep(other_terms, ~ str_detect(.x, \"GDD\"))\n  cdd_terms <- keep(other_terms, ~ str_detect(.x, \"CDD\"))\n\n  other_terms_clean <- setdiff(other_terms, c(gdd_terms, cdd_terms))\n\n  reordered_terms <- c(gdd_terms, cdd_terms, temp_interaction_terms, other_terms_clean, env_interaction_terms)\n  paste(reordered_terms, collapse = \" + \")\n}\n```\n\n## Variable importance\n\n```{r tbl-conservative-variations}\n#| tbl-cap: Number of conservative model variations with delta cAIC < 4 and < 2.\n\ntable <- con_var %>%\n  datatable(rownames = FALSE, filter = 'top', options = list(scrollX = TRUE, pageLength = 10), colnames = c(\"Species\", \"sum Œî cAIC < 4\" , \"sum Œî cAIC < 2\" , \"max ùìå·µ¢ Œî cAIC < 4\", \"max ùìå·µ¢ Œî cAIC < 2\"))\ntable\n```\n\n```{r fig-con-weights-d2, fig.height = 5, fig.width = 10, fig.cap=\"Parameter weights of conservative models with delta cAIC < 4 (D4) and < 2 (D2).\", internal=TRUE}\nweights <- weights_raw %>%\n  filter(MODEL == \"con\") %>%\n  mutate(SPECIES = case_when(\n             model_id %like% \"FS\" ~ \"Fagus\",\n             model_id %like% \"LD\" ~ \"Larix\",\n             model_id %like% \"PA\" ~ \"Picea\",\n             model_id %like% \"TC\" ~ \"Tilia\",\n             TRUE ~ model_id),\n         # Arrange by `category` first, then `term`\n         PARAMETER = factor(PARAMETER, levels = unique(PARAMETER[order(category, PARAMETER)]))) %>%\n  select(-model_id)\n\nggplot(weights, aes(x = SPECIES, y = PARAMETER, fill = WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.8, limit = c(0, 1), na.value = NA) +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"Species\") +\n  ylab(\"Parameter\") +\n  facet_wrap(~DELTA, scales = \"free_x\", ncol = 2) +\n  theme_report() +\n  theme(axis.text.x = element_text(hjust = 0.5))\n```\n\n```{r fig-importance, fig.width=7, fig.height=6, fig.cap=\"Relative variable importance (VI) in high-performing models of leaf unfolding. Shown are the VI of model variations with ŒîcAIC < 2 (cAIC = conditional Akaike Information Criterion) relative to the model with the lowest cAIC that contain GDD and ‚â§ 10 main effects and interactions. A VI of 1 signals high importance relative to other variables, while lower values suggest that a variable appeared in fewer models or models with lower Akaike weights. Variables with the prefix ‚Äúpoly‚Äù were modelled with a non-linear relationship to DOY (Methods). The colon (:) indicates an interaction between two variables. Blanks represent variables that were not present in any well-performing models.\"}\n\nweights <- list.files(path = paste0(path_output_data),\n                     pattern = \"^weights.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  setNames(nm = sapply(basename(.), function(x) {\n    parts <- unlist(strsplit(x, \"_\"))\n    paste(parts[1:2], collapse = \"_\")\n  })) %>%\n  lapply(readRDS) %>% \n  bind_rows() %>%\n  filter(MODEL == \"con\",\n         DELTA == \"D2\") %>%\nmutate(\n  SPECIES_SHORT = str_extract(model_id, \"(?<=con_)[A-Z]{2}\"),\n  SPECIES = recode(SPECIES_SHORT, !!!rename_species_en),\n  order_num = case_when(PARAMETER_ABBR %like% \"Elevation\" ~ 0, # define parameter order within group\n                        PARAMETER_ABBR %like% \"Relief\" ~ 1,\n                        PARAMETER_ABBR %like% \"Slope inclination)\" ~ 2,\n                        PARAMETER_ABBR %like% \"Slope inc\" ~ 3,\n                        PARAMETER_ABBR %like% \"Slope aspect)\" ~ 3,\n                        PARAMETER_ABBR %like% \"CWB\" ~ 15,\n                        PARAMETER_ABBR %like% \"poly(AWC)\" ~ 15,\n                        PARAMETER_ABBR == \"poly(AWC)\" ~ 15,\n                        PARAMETER_ABBR %like% \"Social\" ~ 6,\n                        PARAMETER_ABBR %like% \"Stand\" ~ 7,\n                        PARAMETER_ABBR %like% \"Tree\" ~ 8,\n                        PARAMETER_ABBR == \"CDD\" ~ 9,\n                        PARAMETER_ABBR %like% \"CDD:poly\\\\(GDD\\\\)\" ~ 10,\n                        PARAMETER_ABBR %like% \"poly\\\\(GDD\\\\)\" ~ 11,\n                        PARAMETER_ABBR %like% \"CDD:GDD$\" ~ 12,\n                        PARAMETER_ABBR == \"GDD\" ~ 13,\n                        TRUE ~ 0),\n  category = case_when(PARAMETER_ABBR %like% \"CWB\" ~ \"Climate / Soil\",\n                              PARAMETER_ABBR %like% \"AWC\" ~ \"Climate / Soil\",\n                              category %like% \"Temperature\" ~ \"Climate / Soil\",\n                              TRUE ~ category),\n  PARAMETER = fct_reorder(PARAMETER_ABBR, order_num), # apply parameter order within group\n  category = fct_relevel(category, \"Stand structure\", \"Climate / Soil\", \"Topography\", \"Other\"), # order parameter groups\n  WEIGHT = round(WEIGHT, 2)\n  #PARAMETER = str_remove_all(PARAMETER_ABBR, \"[\\\\(\\\\)]\") %>% str_replace_all(\" \", \"_\")\n  )\n  \nggplot(weights, aes(x = SPECIES, y = PARAMETER, fill = WEIGHT)) +\n  geom_tile() +\n  scale_fill_gradient2(low = \"white\", mid = \"grey\", high = \"#9CB51D\", midpoint = 0.5, limit = c(0, 1), na.value = NA, name = \"VI\") +\n  geom_text(aes(label = round(WEIGHT, 2)), size = 3, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"\") +\n  ylab(\"\") +\n  #scale_y_discrete(position = \"right\") +\n  scale_x_discrete(position = \"top\") +\n  facet_nested(rows = vars(category), scales = \"free_y\", space = \"free_y\", switch = \"y\") +\n  theme_report(legend.position=\"right\") +\n  theme(\n    legend.title = element_text(size = 12, face = \"bold\", hjust=0.1),\n    axis.text.x = element_text(hjust = 0.5),\n    strip.background = element_blank(),\n    strip.text = element_text(face = \"bold\", size = 10, hjust = 0.5),\n    panel.spacing.y = unit(1.5, \"lines\"),\n    axis.line.y = element_line(colour = \"grey\", linewidth = 1.2),\n    panel.grid = element_blank()\n    #panel.border = element_rect(color = \"grey\", fill = NA, linewidth = 0.5)\n    )\n```\n\n## Model selection\n\n```{r tbl-all-models, internal = TRUE}\n#| tbl-cap: Delta cAIC per type of all conservative candidate models across species.\n\nmodel_selection_all <- selection_parameters %>%\n  group_by(SPECIES_SHORT, family) %>%\n  ungroup() %>%\n  select(type, model_name, d.cAIC_group, SPECIES_SHORT) %>% \n  pivot_wider(names_from = SPECIES_SHORT, values_from = d.cAIC_group) %>%\n  filter(model_name %like% \"con\", # select conservative models\n         !model_name %like% \"temp_test\", # remove temperature test models\n         !model_name %like% \"global\" # remove global models\n         )\n\ntable <- model_selection_all %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\n\ntable\n```\n\n```{r set-filter-and-order}\nmodel_filter <- selection_parameters %>%\n  filter(model_name %like% \"con\", # select conservative \n         model_name %like% \"best_con_1\" | model_name %like% \"parsimonious_con_d2\" | model_name == \"ref_imp_con_int\" | model_name %like% \"ref_true_con_int\") %>%\n  pull(model_name)\n\nmodel_order <- c(\"best model\", \"parsimonious 1\", \"parsimonious 2\", \"parsimonious 3\", \"refined reference\", \"traditional reference\")\n```\n\n```{r tbl-select-best-per-group, internal=TRUE}\n#| tbl-cap: Conservative model types with the lowest cAIC across species.\n\ntable <- selection_parameters %>%\n  select(model_name, type, cAIC, SPECIES_SHORT) %>% \n  pivot_wider(names_from = SPECIES_SHORT, values_from = cAIC) %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, extenstions=\"Buttons\", dom = 'Bfrtip',\n    buttons = \"print\"), rownames=FALSE)\n\ntable\n```\n\n```{r tbl-delta-caic}\n#| tbl-cap: Delta cAIC of best conservative models per type across species.\n\ndelta_caic <- selection_parameters %>%\n  select(model_name, type, cAIC, logLik, RMSE, terms_count, SPECIES_SHORT) %>%\n  filter(model_name %in% model_filter) %>%\n  group_by(SPECIES_SHORT) %>%\n  mutate(d.cAIC = cAIC - min(cAIC, na.rm = TRUE),\n         RMSE_PERC = round(100 * RMSE / max(RMSE), 0)) %>%  # recalculate the delta values here to be sure they are correct\n  mutate(type = factor(type, levels = model_order)) %>%\n  arrange(SPECIES_SHORT, type)\n\nsaveRDS(delta_caic %>% ungroup(), paste0(path_output_data, \"/delta_caic.rds\"))\n\ntable <- delta_caic %>%\n  mutate_if(is.numeric, round, 2) %>%\n  select(SPECIES_SHORT, type, cAIC, d.cAIC, logLik, RMSE, RMSE_PERC, terms_count) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Model type\" , \"cAIC\", \"ŒîcAIC\" , \"log (ùìõ)\", \"RMSE\", \"% RMSE\", \"K\"))\ntable\n```\n\n```{r tbl-delta-RMSE, internal=TRUE}\n#| tbl-cap: Delta RMSE of best conservative models per type across species.\n\ndelta_rmse <- selection_parameters %>%\n  select(model_name, type, RMSE, SPECIES_SHORT) %>% \n  pivot_wider(names_from = SPECIES_SHORT, values_from = RMSE) %>%\n  filter(model_name %in% model_filter) %>% \n  mutate(across(where(is.numeric), ~ . - min(., na.rm = TRUE)),\n         type = factor(type, levels = model_order)) %>%\n  arrange(type) %>%\n  select(-model_name)\n\nsaveRDS(delta_rmse, paste0(path_output_data,\"/delta_rmse.rds\"))\n\ntable <- delta_rmse %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n```{r tbl-calls}\n#| tbl-cap: Model formula of best conservative models per type across species.\n\nbest_calls <- selection_parameters %>%\n  filter(model_name %in% model_filter) %>%\n  select(model_name, type, fixed_effects, SPECIES_SHORT) %>%\n  pivot_wider(names_from = SPECIES_SHORT, values_from = fixed_effects) %>%\n  mutate(type = factor(type, levels = model_order)) %>% \n  arrange(type) %>%\n  rename(Beech = FS,\n         Larch = LD,\n         Spruce = PA,\n         Lime = TC) %>%\n  select(-model_name) %>%\n  mutate(across(2:5, label_stats_fun),\n         across(2:5, ~map_chr(.x, rearrange_terms)))\n\nsaveRDS(best_calls, paste0(path_output_data, \"/calls_selected.rds\"))\n\ntable <- best_calls %>%\n  mutate_if(is.numeric, round, 2) %>%\n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10, dom = 'Bfrtip'), rownames=FALSE)\ntable\n```\n\n```{r fig-selection-parameters-con, fig.height=6, fig.cap=\"Comparison of cAIC and RMSE across best conservative models per type. cAIC for Tilia cordata was scaled by 1.63 the improve readability.\", internal=TRUE}\nggplot(selection_parameters %>%\n         filter(model_name %in% model_filter) %>% \n         mutate(cAIC = case_when(SPECIES_SHORT == \"TC\" ~ cAIC * 1.63,\n                                 TRUE ~ cAIC)) %>%\n         pivot_longer(cols = c(cAIC, RMSE), names_to = \"selection_parameter\", values_to = \"value\") %>%\n         mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species),\n         type = factor(type, levels = c(model_order, setdiff(unique(type), model_order)))),\n       aes(x = type, y = value, colour=SPECIES)) +\n  #geom_rect(data=selection_parameters[1,], aes(xmin = 1-0.5, xmax = 2+0.5, ymin = -Inf, ymax = Inf), size=2, fill = \"#9CB51D\", alpha = 0.1, inherit.aes = FALSE) +\n  geom_point(alpha=0.5, size = 2) +\n  #geom_line(aes(group=SPECIES), alpha=0.5) +\n  ylab(\"Selection parameter\") +\n  xlab(\"Model name\") +\n  species_color_scale() +\n  facet_wrap(~selection_parameter, scales = \"free_y\") +\n  theme_report(angle=90, legend.position = \"top\")\n```\n\n## Model prediction accuracy\n\n```{r fig-fixed-vs-observed, fig.width=5, fig.height = 5, fig.cap =\"Model prediction accuracy using refined temperature-only models (black) and best models (green) to predict leaf unfolding across populations. Across-population predictions are based solely on fixed effects, excluding random effects and thus representing a generalized prediction. The dashed lines indicate perfect prediction of leaf unfolding, and deviations from it reflect prediction error.\"}\nggplot(data_unscaled %>%\n         left_join(augment %>%\n                     select(METEO_ID, year, .fixed, model_name, SPECIES_SHORT), by=c(\"METEO_ID\", \"year\", \"SPECIES_SHORT\")) %>%\n         filter(str_detect(model_name, \"best_con_1|ref_imp_con_int$\") & !str_detect(model_name, \"slo\")) %>%\n         mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en))) +\n  geom_point(aes(y=.fixed, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.4)+\n  geom_abline(slope = 1, intercept = 0, color = \"black\", linetype = \"dashed\", size = 0.5) +\n  #geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  geom_smooth(aes(y=.fixed, x= doy, group=model_name, colour=model_name), method=\"lm\", se=FALSE)+\n  facet_wrap(~SPECIES, ncol = 2, scales = \"fixed\") +\n  ylab(\"Predicted day of year\") +\n  xlab(\"Observed day of year\") +\n  scale_colour_manual(\n    values = c(\"best_con_1\" = \"#43CD80\", \"ref_imp_con_int\" = \"#666666\"),\n    labels = c(\"best_con_1\" = \"Best model\", \n               \"ref_imp_con_int\" = \"Refined model\"))+\n  theme_report(legend.position=\"top\", angle=90) +\n  theme(strip.background = element_rect(fill = NA, colour = NA, size = 1),\n        strip.text = element_markdown(hjust = 0.5, face = \"bold\"),\n        panel.border = element_rect(color = \"#CCCCCC\", fill = NA, linewidth=0.005))\n```\n\n```{r fig-predicted-vs-observed-scatter-all, fig.width=8, fig.height = 10, fig.cap =\"Fitted ~ observed and Fixed ~ observed day of year for each model across SPN sites.\", internal = TRUE}\nggplot(data_unscaled %>%\n         left_join(augment %>%\n                     select(METEO_ID, year, .fitted, .fixed, model_name, SPECIES_SHORT), by=c(\"METEO_ID\", \"year\", \"SPECIES_SHORT\")) %>%\n         filter(str_detect(model_name, \"best_con_1|ref_imp_con_int$\") & !str_detect(model_name, \"slo\")) %>%\n         pivot_longer(cols=c(.fitted, .fixed), names_to=\"PARAMETER\", values_to = \"VALUE\") %>%\n         mutate(PARAMETER = case_when(PARAMETER == \".fixed\" ~ \"across population\",\n                           PARAMETER == \".fitted\" ~ \"within population\"))) +\n  geom_point(aes(y=VALUE, x= doy, group=model_name, colour=model_name), shape=21, alpha = 0.2)+\n  geom_abline(slope = 1, intercept = 0, color = \"black\", linetype = \"dashed\", size = 0.5) +\n  #geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"loess\", se=FALSE)+\n  geom_smooth(aes(y=VALUE, x= doy, group=model_name, colour=model_name), method=\"lm\", se=FALSE)+\n  facet_wrap(~ interaction(PARAMETER, SPECIES_SHORT, sep = \" \"), ncol = 2, scales = \"free\") +\n  ylab(\"Predicted day of year\") +\n  xlab(\"Observed day of year\") +\n  scale_colour_manual(\n    values = c(\"best_con_1\" = \"#43CD80\", \"ref_imp_con_int\" = \"#666666\"),\n    labels = c(\"best_con_1\" = \"Best model\", \n               \"ref_imp_con_int\" = \"Refined model\"))+\n  theme_report(legend.position=\"top\", angle=90)\n```\n\n```{r fig-predicted-vs-observed-all-site, fig.height=15, fig.cap =\"Observed vs. fitted day of year for each final slope, best model and traditional and refined reference model for each species and SPN site.\", internal = TRUE}\nggplot()+\n  geom_line(data=data_unscaled, aes(x= year, y=doy, group=SAMPLE_CODE), colour=\"#BFBFBF\", size=1)+\n  geom_point(data=data_unscaled, aes(x= year, y=doy, group=SAMPLE_CODE), colour=\"#A1A1A1\", size=1.2)+\n  geom_line(data=augment %>% filter(model_name %in% model_filter), aes(x=year, y=.fitted, group=GROUP, colour=model_name), size = 0.5, alpha=0.5)+\n  geom_point(data=augment %>% filter(model_name %in% model_filter), aes(x=year, y=.fitted, group=GROUP, colour=model_name), size = 0.5, alpha= 0.5)+\n  facet_wrap(~METEO_ID, scale=\"free_y\", ncol=4)+\n  theme_report(legend.position = \"top\", angle=90)\n```\n\n```{r fig-predicted-vs-observed-selected, fig.height=7, fig.cap =\"Observed vs. fitted day of year for each final slope, best model and traditional and refined reference model for each species at the SPN site Thusis. Thusis was chosen because the site has a long and reliable time series of all four species.\", internal = TRUE}\n# alternative sites are ALD and DIH\n\nggplot(data=data_unscaled %>% filter(METEO_ID ==\"TUS\") %>% mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species)))+\n  geom_line(aes(x= year, y=doy, group=SPECIES_SHORT), colour=\"#BFBFBF\", size=1.5)+\n  geom_point(aes(x= year, y=doy, group=SPECIES_SHORT), colour=\"#A1A1A1\", size=1.5)+\n  geom_line(data=augment %>% filter(METEO_ID == \"TUS\", model_name %in% model_filter) %>% mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species)), aes(x=year, y=.fitted, group=model_name, colour=model_name), size = 1, alpha=0.5)+\n  geom_point(data=augment %>% filter(METEO_ID == \"TUS\", model_name %in% model_filter) %>% mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species)), aes(x=year, y=.fitted, group=model_name, colour=model_name), size = 1, alpha= 0.5)+\n  facet_wrap(~SPECIES, scale=\"free\", ncol=2)+\n  theme_report(legend.position = \"top\", angle=90)\n```\n\n## Coefficients\n\n```{r format-heatmap-input, internal = TRUE}\nheat_input <- coeff_table %>%\n  select(SPECIES, label, term, estimate, model_name, p.value) %>%\n  filter(term !=\"(Intercept)\",\n         !term %like% \"sd_\",\n         !term %like% \"cor\") %>%\n  mutate(p.value = round(p.value, 2))\n```\n\n```{r heat-plot-fun, internal = TRUE}\nheat_fun <- function(data, filter_string){\n  data_filtered <- data %>% filter(str_detect(model_name, filter_string))\n  \nggplot(data_filtered, aes(x = model_name, y = label, fill = estimate > 0)) +\n  geom_tile() +\n  scale_fill_manual(values = c(\"TRUE\" = \"#FFA07A\", \"FALSE\" = \"#BFEFFF\"), \n                    labels = c(\"FALSE\" = \"delaying\", \"TRUE\" = \"advancing\"), \n                    name = \"Effect\", \n                    na.value = NA) + # use this if coefficient size is not interpretable\n  # scale_fill_gradient2(low = \"#009ACD\", mid = \"grey\", high = \"#EE7600\", midpoint = 0, limit = c(min(data_filtered$estimate), max(data_filtered$estimate)), na.value = NA) + # use this if you want the gradient to reflect coefficient size\n  geom_tile(data = subset(data_filtered, p.value < 0.05), color = \"#6E6E6E\", linewidth = 0.5, fill = NA) +\n  facet_wrap(~SPECIES, scales = \"fixed\", ncol = 4) +\n  xlab(\"Model\") +\n  ylab(\"Parameter\") +\n  theme_report(angle = 90, legend.position = \"top\")\n\n}\n```\n\n```{r coeff-plot-fun}\ncoeff_fun <- function(data, filter_string, facet, rows) {\n  filtered_data <- data %>%\n    filter(\n      !term %like% \"sd\",\n      !term %like% \"cor\",\n      !term %like% \"Intercept\",\n      str_detect(model_name, filter_string)\n    ) %>%\n    arrange(term) %>%\n    mutate(\n      term = factor(term, levels = unique(term)),\n      label = factor(label, levels = unique(label)),\n      significance = factor(ifelse(p.value < 0.05, \"significant\", \"not significant\"), \n                            levels = c(\"significant\", \"not significant\"))\n    )\n  \n  ggplot(filtered_data, aes(x = estimate, y = label)) +\n    geom_vline(xintercept = 0, linetype = \"dashed\", size = 1, colour = \"grey\") +\n    geom_pointrange(aes(xmin = conf.low, xmax = conf.high, colour=significance), \n                    position=position_jitter(width=0.5), shape=21) +\n    scale_colour_manual(values = c(\"significant\" = \"#008B00\", \"not significant\" = \"grey\")) +\n    guides(colour = guide_legend(title = NULL)) +\n    facet_wrap(as.formula(paste0(\"~\", facet)), scales = \"free_x\", nrow = rows) +\n    ylab(\"\") +\n    xlab(\"Estimate\") +\n    theme(panel.border = element_rect(color = \"grey\", fill = NA, size = 0.4)) +\n    theme_report(legend.position = \"top\", angle = 90)\n}\n```\n\n\n### Reference models\n\nReference models with random slopes for warming and chilling never converged, even when warming was simplified to a linear term only. Models with a random slope for warming but not chilling converged only for Larix decidua and Tilia cordata, but not Picea abies and Fagus sylvatica. In general reference models for Fagus sylvatica had more conversion issues than reference models of other species.\n\n```{r fig-forrest-reference, fig.cap=\"Coefficient estimate and standard error per term for all zero models.\", fig.retina=2}\ncoeff_fun(coeff_table, \"ref_imp\", \"SPECIES\", 1)\n```\n\n```{r fig-heatmap-reference, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across zero models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"ref_imp_con_int_\") +\n    facet_wrap(~SPECIES, scales = \"free_x\", ncol=4)\n```\n\n```{r tbl-coefficients-refined}\n#| tbl-cap: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of refined models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals.\n\ntbl <- p_table_refined %>%\n    select(SPECIES, PARAMETER, everything(), -term, -model_name, -statistic, -category, -visual, -SPECIES_SHORT, -label, -GROUP) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Predictor\", \"conf.low\", \"estimate\" , \"conf.high\", \"SE\", \"p-value\")\n)\ntbl\n```\n\n<!-- start:internal -->\n### Global models\n\n```{r fig-forrest-global, fig.widht= 20, fig.height=6, fig.cap=\"Coefficient estimate and standard error per term for all global models.\", internal = TRUE}\ncoeff_fun(coeff_table, \"global\", \"SPECIES\", 1)\n```\n\n```{r fig-model-heatmap-global, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across global models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"global\")\n```\n<!-- end:internal -->\n\n### Best models\n\n```{r fig-forrest-best, fig.widht= 40, fig.height=6, fig.cap=\"Coefficient estimate and standard error per term for all best models.\", internal = TRUE}\ncoeff_fun(coeff_table, \"best\", \"SPECIES\", 1)\n```\n\n```{r fig-model-heatmap-best, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across best models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"best\")\n```\n\n```{r tbl-coefficients-best}\n#| tbl-cap: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of best models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals. The reference levels for relief position and social situation are ‚Äúupper slope‚Äù and ‚Äúforest‚Äù, respectively.\n\ntbl <- p_table %>%\n    select(SPECIES, PARAMETER, everything(), -term, -model_name, -statistic, -category, -visual, -SPECIES_SHORT, -label, -GROUP) %>% \n    datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Predictor\" , \"conf.low\", \"estimate\" , \"conf.high\", \"SE\", \"p-value\")\n)\ntbl\n```\n\n### Parsimonious models\n\n```{r fig-forrest-parsimonious, fig.widht= 40, fig.height=6, fig.cap=\"Coefficient estimate and standard error per term for all parsimonious models.\", internal = TRUE}\ncoeff_fun(coeff_table, \"pars\", \"SPECIES\", 1)\n```\n\n```{r fig-model-heatmap-parsimonious, fig.width=15, fig.height=8, fig.cap=\"Overview of parameter effects across parsimonious models. Framed sections represent significant p-values.\", internal = TRUE}\nheat_fun(heat_input, \"pars\")\n```\n\n```{r tbl-coefficients-pars}\n#| tbl-cap: Coefficient estimates, confidence limits of 95% confidence intervals (conf.low, conf.high), standard error (SE) of coefficient estimates and p-values of most parsimonious models. The terms sd Intercept and sd Residuals describe the standard deviation of the random intercept and the residuals. The reference levels for relief position and social situation are ‚Äúupper slope‚Äù and ‚Äúforest‚Äù, respectively.\n\ntbl <- p_table_parsimonious %>%\n  mutate(model_name = case_when(model_name %like% \"parsimonious.*a\" ~ \"parsimonious 1\",\n                                model_name %like% \"parsimonious.*b\" ~ \"parsimonious 2\",\n                                model_name %like% \"parsimonious.*c\" ~ \"parsimonious 3\",\n                                TRUE ~ model_name)) %>%\n  arrange(SPECIES, model_name) %>% \n  select(SPECIES, model_name, PARAMETER, everything(), -term, -statistic, -category, -visual, -SPECIES_SHORT, -label, -GROUP) %>% \n  datatable(filter = 'top', options = list(scrollX = TRUE, pageLength = 10), rownames=FALSE, colnames = c(\"Species\", \"Model\", \"Predictor\" , \"conf.low\", \"estimate\" , \"conf.high\", \"SE\", \"p-value\"))\ntbl\n```\n\n<!-- start:internal -->\n## Confounding effects\n```{r fig-coefficient-shifts, fig.height=8, fig.width=6, fig.cap=\"Shifts in p-value and coefficients of GDD and CDD terms across best, parsimonious, refined and traditional reference models.\"}\ncoefficient_shifts <- coeff_table %>%\n  filter(str_detect(term, \"GDD|CDD\"),\n         model_name %in% model_filter) %>%\n  select(label, model_name, SPECIES, p.value, estimate) %>%\n  arrange(SPECIES) %>%\n  group_by(SPECIES, label) %>%\n  filter(n() > 1) %>%\n  arrange(SPECIES, model_name) %>%\n  pivot_longer(c(p.value, estimate), names_to = \"PARAMETER\", values_to = \"VALUE\")\n\nggplot(coefficient_shifts, aes(x = label, y = VALUE, colour=SPECIES)) +\n  geom_jitter(alpha=0.5, size = 2, width=0.2) +\n  species_color_scale(\"short\") +\n  labs(x = \"Parameter\", y=\"\") +\n  facet_wrap(~PARAMETER, scales = \"free_y\", ncol = 1) +\n  theme_report(angle=90, legend.position = \"top\")\n```\n<!-- end:internal -->\n\n## Effects of variables\n\n```{r plot-all-effects-fun, internal = TRUE}\neffects_all_fun <- function(data, order, label) {\n  data <- data %>%\n    filter(!is.na(x)) %>% \n    mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en),\n           Label = factor(Label, levels = c(order, setdiff(unique(Label), order)))) %>%\n    group_by(Label) %>%\n    mutate(Letters = paste0(\"<b>\", letters[cur_group_id()], \"</b>\")) %>%\n    ungroup()\n\n  ggplot(data, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high)) +\n    geom_line(size = 1, aes(group = interaction(SPECIES, model_name), colour = SPECIES)) +\n    geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = SPECIES_SHORT, group = interaction(SPECIES, model_name)), \n                fill = \"grey\", alpha = 0.3, color = NA) +\n    facet_wrap(~Letters + Label, scales = \"free_x\") +\n    labs(x = \"\", y = \"Day of Year\") +\n    #coord_cartesian(ylim = c(60, 150))+ #specified as coord carthesian to avoid cutting confidence intervals outside the ylim\n    ylim(50, 160)+\n    species_color_scale(label) +\n    theme_report(legend.position = \"top\", hjust = 0.5) +\n    theme(\n      strip.background = element_rect(fill = NA, colour = NA, size = 1),\n      panel.spacing = unit(1, \"lines\"),\n      strip.text = element_markdown(hjust=0)\n    )\n}\n```\n\n```{r load-all-models}\nall_models <- list.files(path = paste0(path_output_data),\n                     pattern = \"^models.*\\\\.rds$\",\n                     full.names = TRUE) %>%\n  lapply(readRDS) %>% \n  bind_rows()\n```\n\n```{r fun-process-and-predict-all-models}\nprocess_and_predict_df <- function(model_df, family) {\n  predictions_df <- NULL\n  filtered_model_df <- model_df %>% filter(str_detect(model_name, family))\n    \n  random_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n  assign(\"random_simple\", random_simple, envir = .GlobalEnv)\n    \n  autoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n  assign(\"autoregression_simple\", autoregression_simple, envir = .GlobalEnv)\n  \n  for (i in seq_len(nrow(filtered_model_df))) {\n    model <- filtered_model_df$model[[i]] # filter model\n    fixed_effects <- formula(model) # get fixed effects\n    model[[\"call\"]][[\"fixed\"]] <- as.formula(fixed_effects) # paste fixed effect back into the model to replace \"fixed effects\"\n    terms <- filtered_model_df[[\"terms\"]][[i]] # get terms\n\n    for (term in terms) {\n      # make prediction\n      prediction <- tryCatch({\n        predict_response(model, terms = paste(term, \"[all]\", sep = \" \"))\n      }, error = function(e) {\n        NULL  # Return NULL on error\n      }) %>%\n        as.data.frame() %>% # transform prediction output to data frame\n        mutate(model_name = paste0(filtered_model_df$model_name[[i]]), # add model name\n               SPECIES_SHORT = paste0(filtered_model_df$SPECIES_SHORT[[i]])) # add species\n      \n      if (!is.null(prediction)) {\n        prediction$x <- as.numeric(as.character(prediction$x))\n        #prediction$Model <- species\n        prediction$Term <- term\n        \n        if (is.null(predictions_df)) {\n          predictions_df <- prediction\n        } else {\n          predictions_df <- bind_rows(predictions_df, prediction) %>% as.data.frame() %>% mutate(Label = label_fun_sim(Term, col = \"short\"))\n        }\n      }\n    }\n  }\n  \n  predictions_df\n}\n\nsaveRDS(process_and_predict_df, paste0(path_helpers, \"/process_and_predict_df.rds\"))\n```\n\n<!-- start:internal -->\n### Best models\n<!-- end:internal -->\n\n```{r extract-effects-best-con, include=FALSE}\n# categoric variables\nmodels_categoric <-  all_models %>% filter(model_name == \"best_con_1\", SPECIES_SHORT == \"LD\")\n\nrandom_simple <- readRDS(paste0(path_output_data, \"/random_simple.rds\"))\n  assign(\"random_simple\", random_simple, envir = .GlobalEnv)\n    \nautoregression_simple <- readRDS(paste0(path_output_data, \"/autoregression_simple.rds\"))\n  assign(\"autoregression_simple\", autoregression_simple, envir = .GlobalEnv)\n\neffects_relief <- predict_response(models_categoric[[3]][[1]], terms = \"RELIEF [all]\", sep = \" \") %>%\n  as.data.frame() %>%\n  mutate(Term = \"RELIEF\",\n         SPECIES_SHORT = \"LD\")\n\neffects_social <- predict_response(models_categoric[[3]][[1]], terms = \"SOCIAL_SITUATION [all]\", sep = \" \") %>%\n  as.data.frame() %>%\n  mutate(Term= \"SOCIAL_SITUATION\",\n         SPECIES_SHORT = \"LD\")\n\neffects_best_con_categoric <- bind_rows(effects_social, effects_relief) %>%\n  mutate(PARAMETER = label_fun_sim(as.character(Term)),\n         Label = label_fun_sim(as.character(Term), col = \"short\"),\n         SPECIES = recode(SPECIES_SHORT, !!!rename_species_en))\n\n# numeric variables\neffects_best_con_numeric <- process_and_predict_df(all_models, \"best_con_1\") %>%\n  mutate(Label = label_fun_sim(as.character(Term), col = \"short\"))\n```\n\n```{r effect-size-best-con}\n# standardize effect size and estimate potential effect on net ecosystem productivity in CO2\neffects_best_numeric <- effects_best_con_numeric %>% mutate(x = as.character(x))\neffects_best_categoric <- effects_best_con_categoric %>% mutate(x = as.character(x))\n\neffect_size_best <- bind_rows(effects_best_numeric, effects_best_categoric) %>%\n  group_by(SPECIES_SHORT, Term, Label) %>%\n  summarise(MAX_MEAN_EFFECT_SIZE = round(max(predicted) - min(predicted), 2),\n            MEAN_STD_ERROR = round(mean(std.error), 2),\n            MIN_TERM = x[which.min(predicted)],\n            MAX_TERM = x[which.max(predicted)],\n            CARBON_PREDICTION = MAX_MEAN_EFFECT_SIZE * 4) %>%\n  arrange(desc(CARBON_PREDICTION)) %>%\n  filter(!is.na(Label),# remove excess labels from categoric variables\n         MAX_MEAN_EFFECT_SIZE > 0) %>% \n  rename(PARAMETER = Term) %>% \n  mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en)) %>%\n  ungroup() %>% \n  select(Label, SPECIES, everything())\n\nsaveRDS(effect_size_best %>% ungroup(), paste0(path_output_data, \"/effect_size_best_con.rds\"))\n```\n\n```{r fig-effect-size, fig.height=5, fig.width=6, fig.cap=\"Estimated shift (d) between earliest and latest DOY across the observed range of each environmental variable, based on predictions adjusted to mean covariate values. For each species, colours are scaled so the darkest shade represents the strongest shift.\"}\nfacet_stats <- effect_size_best %>%\n  group_by(SPECIES) %>%\n  summarise(\n    min_val = min(MAX_MEAN_EFFECT_SIZE, na.rm = TRUE),\n    max_val = max(MAX_MEAN_EFFECT_SIZE, na.rm = TRUE),\n    mid_val = mean(MAX_MEAN_EFFECT_SIZE, na.rm = TRUE),\n    .groups = \"drop\")\n\neffect_scaled <- effect_size_best %>%\n  left_join(facet_stats, by = \"SPECIES\") %>%\n  mutate(scaled_effect = (MAX_MEAN_EFFECT_SIZE - min_val) / (max_val - min_val)) %>%\n  inner_join(label_table %>% select(term, param_order_c1, category), by = c(\"PARAMETER\" = \"term\")) %>% # partial join with order of parameters\n  mutate(category = case_when(category == \"Soil\" ~ \"Climate / Soil\",\n                              category == \"Drought\" ~ \"Climate / Soil\",\n                              category == \"Climate\" ~ \"Climate / Soil\",\n                              TRUE ~ category),\n         Label = case_when(Label %like% \"Social\" ~ \"Social position\",\n                          TRUE ~ Label),\n         order_num = case_when(PARAMETER %like% \"ELEVATION\" ~ 0, # define parameter order within group\n                        PARAMETER %like% \"RELIEF\" ~ 1,\n                        PARAMETER %like% \"INCLINATION\" ~ 2,\n                        PARAMETER %like% \"ASPECT\" ~ 3,\n                        PARAMETER %like% \"SOCIAL\" ~ 6,\n                        PARAMETER %like% \"STAND\" ~ 7,\n                        PARAMETER %like% \"HEIGHT\" ~ 8,\n                        PARAMETER %like% \"DROUGHT\" ~ 13,\n                        PARAMETER %like% \"AWC\" ~ 12,\n                        PARAMETER %like% \"CDD\" ~ 10,\n                        PARAMETER %like% \"GDD\" ~ 11,\n                        TRUE ~ 0),\n         PARAMETER = fct_reorder(Label, order_num),\n        category = fct_relevel(category, \"Stand structure\", \"Climate / Soil\", \"Topography\")) # order parameter groups\n\nggplot(effect_scaled, aes(x = SPECIES, y = PARAMETER, fill = scaled_effect)) +\n  geom_tile() +\n  scale_fill_gradient2(\n    low = \"#FFA54F\", mid = \"#FF7F24\", high = \"#CD661D\", midpoint = 0.5, limits = c(0, 1)) +\n  geom_text(aes(label = round(MAX_MEAN_EFFECT_SIZE, 2)), size = 4, vjust = 0, colour = \"#4F4F4F\") +\n  xlab(\"\") +\n  ylab(\"\") +\n  scale_x_discrete(position = \"top\") +\n  facet_nested(rows = vars(category), scales = \"free_y\", space = \"free_y\", switch = \"y\") +\n  theme_report(legend.position = \"none\") +\n  theme(\n    legend.title = element_text(size = 12, face = \"bold\", hjust = 0.1),\n    axis.text.x = element_text(hjust = 0.5, face = \"bold\"),\n    strip.background = element_blank(),\n    strip.text.y.left = element_text(face = \"bold\", size = 10, hjust = 0.5, colour = \"#757575\"),\n    panel.spacing.y = unit(1.1, \"lines\"),\n    axis.line.y = element_line(colour = \"grey\", linewidth = 1.2),\n    panel.grid = element_blank()\n  )\n```\n\n```{r effects-nature-fun}\ntheme_nature <- function() {\n  theme(\n    legend.position = \"none\",\n    axis.text.x = element_text(size = 10, vjust = 0.5, hjust = 0.5),\n    axis.text.y = element_blank(),\n    axis.ticks = element_blank(),\n    strip.background = element_rect(fill = NA, colour = NA, size = 1),\n    panel.spacing = unit(1, \"lines\"),\n    strip.text = element_markdown(hjust = 0),\n    plot.title = element_text(size = 10),\n    axis.title.x = element_text(size = 10.5),\n    plot.margin = margin(t = 10, b = 10, r = 3, l = 3),\n    panel.border = element_rect(color = \"#E8E8E8\", fill = NA, linewidth=1.5),\n    panel.grid.minor = element_blank()\n  )\n}\n\n# numeric plots\neffects_fun_num <- function(data, label, type = \"line\"){\n  data <- data %>%\n    mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en)) %>%\n      filter(!is.na(x))\n  \n  terms <- unique(data$Term)\n  \n  plots <- list()\n  \n  for (i in terms) {\n    plot_data <- data %>%\n      filter(Term == i)\n\n    p <- ggplot(plot_data, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high)) +\n      geom_line(size = 1, aes(group = interaction(SPECIES, model_name), colour = SPECIES)) +\n      geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = SPECIES_SHORT, group = interaction(SPECIES, model_name)), \n                  fill = \"grey\", alpha = 0.3, color = NA) +\n      labs(x = paste0(\" \", unique(plot_data$Label)), y = \"\") +\n      coord_cartesian(ylim = c(65, 150))+\n      #ylim(60, 160)+\n      #ggtitle(paste0(\" \", unique(plot_data$Letters), unique(plot_data$Label))) +\n      ggtitle(paste0(\" \")) +\n      species_color_scale(paste0(label)) +\n      theme_report() +\n      theme_nature()\n    \n     plots[[i]] <- p\n  }\n    return(plots)\n}\n\n# categorical plots\neffects_fun_cat <- function(data, label, type = \"line\"){\n  terms <- unique(data$Term)\n  \n  plots <- list()\n  \n  data <- data %>%\n    mutate(SPECIES = recode(SPECIES_SHORT, !!!rename_species_en))\n  \n  for (i in terms) {\n    order <- c(\"flat\", \"base\", \"mid\", \"upper\", \"free\", \"group\", \"forest\")\n    \n    plot_data <- data %>%\n      filter(Term == i) %>%\n      mutate(x = case_when(x %like% \"crest\" ~ \"upper\",\n                           x %like% \"base\" ~ \"base\",\n                           x %like% \"mid\" ~ \"mid\",\n                           x %like% \"stand\" ~ \"free\",\n                           TRUE ~ x), \n             x = factor(x, levels = c(order, setdiff(unique(x), order))))\n\n    p <- ggplot(plot_data, aes(x = x, y = predicted, ymin = conf.low, ymax = conf.high)) +\n      geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2, colour= \"grey\") +\n      geom_point(aes(colour = SPECIES), size = 2.5) +\n      labs(x = paste0(\" \", unique(plot_data$PARAMETER)), y = \"\") +\n      coord_cartesian(ylim = c(65, 150))+\n      #ylim(60, 160)+\n      #ggtitle(paste0(\" \", unique(plot_data$PARAMETER))) +\n      ggtitle(paste0(\" \")) +\n      species_color_scale(paste0(label)) +\n      theme_report() +\n      theme_nature()\n\n     plots[[i]] <- p\n  }\n    return(plots)\n}\n```\n\n```{r generate-plots}\n# Generate numeric and categorical plots\nplots_num_all <- effects_fun_num(effects_best_con_numeric, \"english\")\nplots_cat_par <- effects_fun_cat(effects_best_con_categoric, \"english\")\n\n# Extract legend from the numeric plot\ng_bottom <- ggplotGrob(plots_num_all[[\"GDD_conservative\"]] + theme(legend.position = \"bottom\"))\nlegend_grob_bottom <- g_bottom$grobs[which(sapply(g_bottom$grobs, function(x) x$name) == \"guide-box\")][[1]]\nplot_legend_bottom <- ggdraw() + draw_grob(as_grob(legend_grob_bottom))\n\n# Extract legend from the numeric plot\ng_right <- ggplotGrob(plots_num_all[[\"GDD_conservative\"]] + theme(legend.position = \"right\"))\nlegend_grob_right <- g_right$grobs[which(sapply(g_right$grobs, function(x) x$name) == \"guide-box\")][[1]]\nplot_legend_right <- ggdraw() + draw_grob(as_grob(legend_grob_right))\n\n# Bind elements\nplots_list <- c(plots_num_all, plots_cat_par, list(Legend = plot_legend_right) # add legend as object if it should be treated as a plot\n                )\n\n# add axis labels to left side plots\nplots_list[names(plots_list) %in% c(\"TREE_HEIGHT\", \"SLOPE_ASPECT_HL\", \"DROUGHT\")] <-\n  map(plots_list[names(plots_list) %in% c(\"TREE_HEIGHT\", \"SLOPE_ASPECT_HL\", \"DROUGHT\")],\n      ~ .x + theme(axis.text.y = element_text(), axis.ticks.y = element_line()))\n\n# Order plots\ndesired_order <- c(\"TREE_HEIGHT\", \"STAND_HEIGHT\",\n                   \"SOCIAL_SITUATION\", \"AWC\", \"DROUGHT\", \"RELIEF\", \n                   \"SLOPE_ASPECT_HL\", \"SLOPE_INCLINATION_DEG\", \"TREE_ELEVATION\",#, \"Legend\" # add legend as object if it should be treated as a plot\n                   \"GDD_conservative\", \"CDD_conservative\", \"Legend\")  \n\nordered_plots <- plots_list[desired_order]\n\n#letters_list[length(letters_list)] <- \"\"  # Remove letter assigned to legend legend if legend is treated as a plot\n```\n\n```{r order-plots-thematic}\n# Define plot groupings\ngroup_titles <- c(\n  \"Stand structure\",\n  \"Climate / Soil\",\n  \"Topography\"\n#  \"Temperature\"\n)\n\n# Split ordered plots into thematic rows\nplot_rows <- list(\n  ordered_plots[c(\"TREE_HEIGHT\", \"STAND_HEIGHT\", \"SOCIAL_SITUATION\", \"Legend\")],\n  ordered_plots[c(\"DROUGHT\", \"AWC\", \"GDD_conservative\", \"CDD_conservative\")],\n  ordered_plots[c(\"SLOPE_ASPECT_HL\", \"SLOPE_INCLINATION_DEG\", \"RELIEF\", \"TREE_ELEVATION\")])\n\nflat_plots <- unlist(plot_rows, recursive = FALSE)\n# Determine where the \"Legend\" is\nlegend_pos <- which(names(flat_plots) == \"Legend\")\n\n# Create letters and insert \"\" at the right spot\npanel_letters <- letters[1:(length(flat_plots) - 1)]\npanel_letters <- append(panel_letters, \"\", after = legend_pos - 1)\n\n# Define max columns (based on longest row)\nmax_cols <- max(lengths(plot_rows))\n\nn_rows <- length(plot_rows)\nn_cols <- max_cols\n\nx_positions <- rep(seq(0.121, 0.833, length.out = n_cols), times = n_rows)\ny_positions <- rep((seq(1, 0.33, length.out = n_rows)), each = n_cols)\n\n# Function to pad a row to fixed width\npad_row <- function(plots, total_cols = max_cols) {\n  n_missing <- total_cols - length(plots)\n  if (n_missing > 0) {\n    plots <- c(plots, rep(list(NULL), n_missing))  # pad with empty slots\n  }\n  return(plots)\n}\n\nplot_object <- tibble(\n  order = flat_plots[names(flat_plots)],\n  parameter = names(order),\n  letters = panel_letters)\n```\n\n```{r fig-effects-best-all-thematic, fig.width=11, fig.height=7, fig.cap=\"Species-specific environmental drivers beyond temperature shape the timing of leaf unfolding. Panels show the estimated effect of predictors present in species-specific best models, adjusted for the influence of other included covariates at their mean values. Shaded areas and error bars represent 95% confidence intervals.\"}\n# Adjusted label drawer with rotation\nrotated_label <- function(label_text) {\n  ggdraw() + \n    draw_label(\n      label_text,\n      angle = 90,               # rotate\n      hjust = 0.5,              # center vertically\n      vjust = 0.5,\n      size = 13\n      ) + #fontface = \"bold\"\n    theme(plot.margin = margin(t = 0, r = -30, b = 0, l = 0))  # pulls label closer\n}\n\nrotated_label <- function(label_text) {\n  ggdraw() + \n    draw_line(                     # vertical line\n      x = c(-0.3, -0.3),\n      y = c(0.05, 0.95),\n      size = 1.2,\n      color = \"grey\"\n    ) +\n    draw_label(\n      label_text,\n      angle = 90,\n      hjust = 0.5,\n      vjust = 0.5,\n      size = 13\n    ) +\n    theme(plot.margin = margin(t = 0, r = -20, b = 0, l = 0))\n}\n\n# adjust for column with narrow plots due to axis labels\naligned_plot_rows <- map(plot_rows, ~ align_plots(plotlist = pad_row(.x), align = \"hv\", axis = \"tblr\"))\n\nannotated_rows <- map2(aligned_plot_rows, group_titles,\n  ~ plot_grid(\n      rotated_label(.y),\n      plot_grid(plotlist = .x, ncol = max_cols),\n      ncol = 2,\n      rel_widths = c(0.02, 0.99),\n      align = \"v\",\n      axis = \"tb\"))\n\n# Combine into final layout\nfinal_plot <- plot_grid(\n  plotlist = annotated_rows,\n  ncol = 1,\n  rel_heights = rep(1, length(annotated_rows)))  # uniform row heights\n\nfinal_plot_labeled <- ggdraw() +\n  draw_plot(final_plot, x = 0.05, y = 0, width = 0.97, height = 1) +  # shift right to make room\n  draw_label(\n    \"Day of year\",\n    x = 0.01, y = 0.5,\n    angle = 90,\n    fontface = \"bold\",\n    size = 16)\n\nfinal_plot_labeled_with_letters <- ggdraw() +\n  draw_plot(final_plot_labeled) +\n  draw_plot_label(\n    label = panel_letters,  # <- reverse here\n    x = x_positions,\n    y = y_positions,\n    size = 14,\n    fontface = \"bold\") +\n  theme(plot.margin = margin(r = 30))\n\nfinal_plot_labeled_with_letters\n```\n\n<!-- start:internal -->\n### Parsimonious models\n\n```{r process-pars-con}\neffects_pars2d_con <- process_and_predict_df(all_models, \"parsimonious_con_d2\") %>%\n  mutate(Label = label_fun_sim(Term))\n```\n\n```{r fig-effects-pars-con, fig.width=6, fig.height=8, fig.cap=\"Mean effects of parameters on day of year for each most parsimonious conservative model and species.\"}\norder <- c(\"Tree height (m)\", \"Stand height (m)\", \"Available water capacity (cm¬≥)\", \"Climatic water balance (mm)\", \"Growing degree days (¬∞C days)\", \"Chilling degree days (¬∞C days)\", \"Elevation (m)\")\n\norder_de <- c(\"W√§rmesumme (¬∞C Tage)\", \"K√§ltesumme (¬∞C Tage)\", \"Baumh√∂he (m)\", \"Bestandesh√∂he (m)\", \"Wasserspeicherkapazit√§t (cm¬≥)\", \"Klimatische Wasserbilanz (mm)\", \"Seeh√∂he (m)\")\n\neffects_all_fun(effects_pars2d_con, order, \"english\")\n```\n<!-- end:internal -->\n\n### Effects of interactions\n\n```{r interaction-effect-fun}\ninteraction_effect_fun <- function(model_string, species_string, term_string, lab_string, legend_string = c(\"low\", \"medium\", \"high\"), color_string = c(\"#FF7F00\", \"#698B22\", \"#1874CD\")){\n\nfiltered_models <- all_models %>% filter(str_detect(model_name, model_string), str_detect(SPECIES_SHORT, species_string))\nprediction <- predict_response(filtered_models$model[[1]], term = term_string)\n  \nggplot(prediction, aes(x = x, y = predicted)) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group), \n                fill = \"grey\", alpha = 0.3, color = NA)+\n  geom_line(size = 1, aes(group = factor(group), colour = factor(group))) +\n  labs(x = lab_string, y = \"Day of year\", colour = \"Group\") +\n  scale_color_manual(values = color_string, labels = legend_string) +\n  guides(colour = guide_legend(reverse = TRUE)) + # Reverse the legend order\n  theme_report(legend.position = \"top\", hjust = 0.5) +\n  theme_nature()\n}\n```\n\n```{r fig-effects-warming-chilling-tc1, fig.width = 4, fig.height = 4, fig.cap=\"Effect of the interaction between GDD and CDD at low, medium and high CDD in the best model of lime. Predictions are adjusted to mean covariate values, with 95% confidence intervals (grey).\"}\ninteraction_effect_fun(\"best_con_1\", \"TC\", c(\"GDD_conservative [all]\", \"CDD_conservative\"), \"Growing degree days (¬∞C day)\", c(\"low CDD\", \"medium CDD\", \"high CDD\")) +\n  theme_nature()+\n  theme(legend.position = \"top\")\n```\n\n```{r fig-effects-awc-cwb, fig.width = 4, fig.height = 4, fig.cap=\"Effect of the interaction between AWC and CWB at low, medium and high AWC in the best model of spruce. Predictions are adjusted to mean covariate values. Shaded areas represent 95% confidence intervals.\"}\ninteraction_effect_fun(\"best_con_1\", \"PA\", c(\"DROUGHT [all]\", \"AWC\"), \"Climatic water balance (mm)\", c(\"low AWC\", \"medium AWC\", \"high AWC\")) + \n  theme_nature()+\n  theme(legend.position = \"top\")\n```\n\n```{r fig-effects-warming-chilling, fig.width = 4, fig.height = 3, eval=FALSE, internal = TRUE}\n# manual plot for tricky interactions\nfiltered_models <- all_models %>% filter(str_detect(model_name, \"best_con_1\"), str_detect(SPECIES_SHORT, \"TC\"))\nprediction <- ggpredict(filtered_models$model[[1]], term = c(\"GDD_conservative [all]\", \"CDD_conservative [250, 350, 550]\"))\n\nfiltered_prediction <- prediction %>%\n  as.data.frame() %>% \n    mutate(site_type = case_when(\n    group == 250 ~ \"low CDD\",    # Warm site group\n    group == 350 ~ \"medium CDD\",  # Medium site group\n    group == 550 ~ \"high CDD\"     # Cold site group\n  )) %>%\n  filter(\n    # remove CDD-GDD combinations that do not occur in reality\n    (site_type == \"low CDD\" & x >= 200 & x <= 600) |\n    (site_type == \"medium CDD\" & x >= 0 & x <= 300) |\n    (site_type == \"high CDD\" & x >= 0 & x <= 220)\n  )\n\nggplot(filtered_prediction, aes(x = x, y = predicted, colour = site_type)) +\n  geom_line(size = 1, aes(group = interaction(site_type, group))) +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = site_type, group = site_type), \n              alpha = 0.3, colour = NA) +\n  scale_color_manual(values = c(\"high CDD\" = \"#1874CD\", \"low CDD\" = \"#FF7F00\", \"medium CDD\" = \"#698B22\"))+\n  scale_fill_manual(values = c(\"high CDD\" = \"grey\", \"low CDD\" = \"grey\", \"medium CDD\" = \"grey\")) + \n  labs(x = \"Growing Degree Days (¬∞C day)\", y = \"Day of Year\", colour = \"Site Type\", fill = \"Site Type\") +\n  theme_report(legend.position = \"top\", hjust = 0.5)\n```\n\n```{r save-output}\nsaveRDS(model_filter, paste0(path_output_data, \"/model_filter.rds\"))\nsaveRDS(plot_object, paste0(path_output_data, \"/facet_reference.rds\"))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":4,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":"html_document","warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"espresso","toc":true,"toc-depth":3,"include-in-header":{"text":"<script type=\"text/javascript\" src=\"C:/Users/iostovary/Documents/Data/00_helpers/zoom.js\"></script>"},"output-file":"6_species_comparison_leaf_unfolding.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","bibliography":["C:/Users/iostovary/Documents/Data/references.bib"],"csl":"C:/Users/iostovary/Documents/Data/citation_style_global-ecology-and-biogeography_mod_ostovary.csl","editor":"visual","page-layout":"full","code-summary":"Show the code","theme":"minty","code-folding":"hide","grid":{"body-width":"1100px"},"toc-location":"right","toc-float":{"collapsed":false,"number-sections":true},"editor_options":{"chunk_output_type":"inline"}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}